/*
DuikLib
Library with Duik tools.
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

__Contributors:__

	Nicolas Dufresne - Lead developer
	Kevin Masson - Developer

__Thanks to:__

	Dan Ebberts - Writing the first IK Expressions
	Eric Epstein - making the IK's work with 3D Layers
	Kevin Schires – Including images in the script
	Matias Poggini – Bezier IK feature
	Eric Epstein - Making the IK's work with 3D Layers
	Assia Chioukh and Quentin Saint-Georges – User Guides composition
	Motion Cafe – Ideas and feedback
	Fous d’anim – Ideas and feedback
	All 258 Duik 15 indiegogo backers for making this libDuik possible!


This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* Constructs a Structure
* @class Structure
* @classdesc A Structure.
* @property {Layer[]} elements - The elements of the structure, sorted by their parenting, root at 0
*/
function Structure()
{
	this.elements = [];
	this.editModeRegExp = / \|StructureElementChildren:([\d,]*)\|/;
}

/**
* Sets a new display size for the structure
* @memberof Structure
* @param {int} [size] - The element size, a percentage. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
*/
Structure.prototype.setSize = function (size)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}
	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(2).setValue(size);
	}
}

/**
* Sets a new display color for the structure
* @memberof Structure
* @param {float[]} color - The color
*/
Structure.prototype.setColor = function (color)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(color);
	}
}

/**
* Toggles the edit mode
* @memberof Structure
*/
Structure.prototype.toggleEditMode = function (color)
{
	if (this.elements.length == 0) return;

	var setEditMode = !this.editModeRegExp.test(this.elements[0].comment);

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.toggleElementEditMode(i,setEditMode)
	}
}

/**
* Toggles the edit mode of one element in the structure
* @memberof Structure
* @param {int} elementIndex - The index of the element to toggle in the Structure.elements Array
* @param {boolean} setEditMode - true to turn on edit mode, false to turn it off.
*/
Structure.prototype.toggleElementEditMode = function (elementIndex,setEditMode)
{
	var element = this.elements[elementIndex];
	var comp = element.containingComp;
	var already = this.editModeRegExp.test(element.comment);

	if (setEditMode && !already)
	{
		var children = DuAEF.DuAE.Layer.getChildren(element);
		element.comment = element.comment + ' |StructureElementChildren:';
		for (var j = 0 ; j < children.length ; j++)
		{
			var child = children[j];
			element.comment = element.comment + child.index;
			if (j < children.length -1) element.comment = element.comment + ',';
			child.parent = null;
		}
		element.comment = element.comment + "|";
		element.name = '=EDIT= ' + element.name;
	}
	else if (already)
	{
		var match = this.editModeRegExp.exec(element.comment);
		if (match.length == 2)
		{
			var indices = match[1].split(',');
			//reparent
			if (indices.length > 0)
			{
				for (var i = 0 ; i < indices.length ; i++)
				{
					var index = parseInt(indices[i]);
					if (isNaN(index)) continue;
					comp.layer(index).parent = element;
				}
			}
			//remove comment
			element.comment = element.comment.replace(match[0],'');
			element.name = element.name.replace('=EDIT= ','');
		}
	}
}

/**
* Toggles visibility of the structure
* @memberof Structure
*/
Structure.prototype.showHide = function ()
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	var show = !this.elements[0].enabled;

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.elements[i].enabled = show;
	}
}

/**
* Duik tools
* @namespace
* @memberof DuAEF
*/
DuAEF.Duik = {};

//Initialize
(function ()
{
	//structures
	#include "pseudoEffects/duik_structure.ffx.jsxinc"
	duik_structure = DuAEF.DuBinary.toFile(duik_structure);
	//list
	#include "pseudoEffects/duik_1d_list.ffx.jsxinc"
	duik_1d_list = DuAEF.DuBinary.toFile(duik_1d_list);
	#include "pseudoEffects/duik_2d_list.ffx.jsxinc"
	duik_2d_list = DuAEF.DuBinary.toFile(duik_2d_list);
	#include "pseudoEffects/duik_3d_list.ffx.jsxinc"
	duik_3d_list = DuAEF.DuBinary.toFile(duik_3d_list);
	//wiggle
	#include "pseudoEffects/duik_1d_wiggle.ffx.jsxinc"
	duik_1d_wiggle = DuAEF.DuBinary.toFile(duik_1d_wiggle);
	#include "pseudoEffects/duik_1d_multiwiggle.ffx.jsxinc"
	duik_1d_multiwiggle = DuAEF.DuBinary.toFile(duik_1d_multiwiggle);
	#include "pseudoEffects/duik_2d_wiggle.ffx.jsxinc"
	duik_2d_wiggle = DuAEF.DuBinary.toFile(duik_2d_wiggle);
	#include "pseudoEffects/duik_3d_wiggle.ffx.jsxinc"
	duik_3d_wiggle = DuAEF.DuBinary.toFile(duik_3d_wiggle);
	/**
	 * The pseudo effects needed by Duik
	 * @enum {File}
	 * @readonly
	 */
	DuAEF.Duik.pseudoEffects =
	{
		//wiggle
		ONED_WIGGLE: duik_1d_wiggle,
		ONED_MULTIWIGGLE: duik_1d_multiwiggle,
		TWOD_WIGGLE: duik_2d_wiggle,
		THREED_WIGGLE: duik_3d_wiggle,
		//list
		ONED_LIST: duik_1d_list,
		TWOD_LIST: duik_2d_list,
		THREED_LIST: duik_3d_list,
		//structures
		STRUCTURE_ELEMENT: duik_structure
	};

	/**
	 * The pseudo effects match names
	 * @enum {string}
	 * @readonly
	 */
	DuAEF.Duik.pseudoEffectsMatchNames =
	{
		//wiggle
		ONED_WIGGLE: "Pseudo/DUIK 1d wiggle",
		ONED_MULTIWIGGLE: "Pseudo/DUIK 1d multiwiggle",
		TWOD_WIGGLE: "Pseudo/DUIK 2d wiggle",
		THREED_WIGGLE: "Pseudo/DUIK 3d wiggle",
		//list
		ONED_LIST: "Pseudo/DUIK 1d list",
		TWOD_LIST: "Pseudo/DUIK 2d list",
		THREED_LIST: "Pseudo/DUIK 3d list",
		//structures
		STRUCTURE_ELEMENT: "Pseudo/DUIK structure"
	};

	/**
	 * Predefined sizes
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.sizes =
	{
		SMALL: 0,
		MEDIUM: 1,
		LARGE: 2,
		CUSTOM: 3
	};

	/**
	 * How to get structures depending on selection<br />
	 * All structure, only children elements, or only selected element
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.structureSelectionMode =
	{
		STRUCTURE: 0,
		CHILDREN: 1,
		ELEMENT: 2,
		ALL: 3
	}

	/**
	* Size hint of structure elements
	* @type {int}
	* @default DuAEF.Duik.sizes.SMALL
	*/
	DuAEF.Duik.structureSizeHint = DuAEF.Duik.sizes.SMALL;
	/**
	* The default size for new structures if structureSizeHint is DuAEF.Duik.sizes.CUSTOM
	* @type {int}
	* @default 100
	*/
	DuAEF.Duik.structureSize = 100;
	/**
	* The default color for new structures
	* @type {float[]}
	* @default DuAEF.DuJS.Color.Colors.RANDOM
	*/
	DuAEF.Duik.structureColor = DuAEF.DuJS.Color.Colors.RANDOM

})();

/**
* Structures
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Structure = {};

/**
 * Creates a structure in a composition
 * @memberof DuAEF.Duik
 * @param {int}		num	- The number of elements of the structure
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {string}	[name="Name"]	- The name of the structure (used as layer names)
 * @return {Structure|null}	The Structure or null if there is no active composition
 */
DuAEF.Duik.Structure.addStructure = function (num,comp,name)
{
	if (name === undefined) name = "Name";

	//end
	num++;

	//structure
	var structure = {};
	structure.elements = [];

	//elements length
	var length = comp.width/(num+1);

	var prevElement = null;
	var color = DuAEF.Duik.structureColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM)
	{
		color = DuAEF.DuJS.Color.random();
	}

	for (var i = 0 ; i < num ; i++)
	{
		var end = i == num-1;
		var element = DuAEF.Duik.Structure.addStructureElement(comp,color);
		if (end)
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S-End " + name, comp);
		}
		else
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S " + name, comp);
		}

		if (prevElement)
		{
			element.parent = prevElement;
			element.transform.position.setValue([length,0]);
		}
		else
		{
			element.transform.position.setValue([length,comp.height/2]);
		}
		prevElement = element;
		structure.elements.push(element);
	}
	//links and layer selection
	for (var i = 0;i < structure.elements.length ; i++)
	{
		if (i == structure.elements.length - 1)
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i].index);
			structure.elements[i].selected = false;
		}
		else
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i+1].index);
		}
	}
	structure.elements[0].selected = true;

	return structure;
}

/**
 * Creates an element for a structure in a composition
 * @memberof DuAEF.Duik
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {float[]}	[color=[1,0.764,0.764,1]]		- The color of the element, [R,G,B,A] Array from 0.0 to 1.0
 * @param {float}	[size] 		- The element size, un percent. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
 * @return {ShapeLayer}	The element
 */
DuAEF.Duik.Structure.addStructureElement = function (comp,color,size)
{
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}

	if (!color)
	{
		color = DuAEF.Duik.structureColor;
		if (color == DuAEF.DuJS.Color.Colors.RANDOM)
		{
			color = DuAEF.DuJS.Color.random();
		}
	}


	//======= CREATE ELEMENT USING SHAPE LAYER =======
	var element = comp.layers.addShape();
	//add effect

	element.applyPreset(DuAEF.Duik.pseudoEffects.STRUCTURE_ELEMENT);
	element.effect("Structure")(2).setValue(size);
	element.effect("Structure")(4).setValue(color);

	//bone group
	var elementGroup = element("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	elementGroup.name = "Structure Element";
	elementGroup("ADBE Vector Transform Group")("ADBE Vector Scale").expression = '//Duik.structure.size\nif(!enabled) value;\nelse\n{\nvar s = effect("Structure")(2);\n[s,s];\n}';
	//target group
	var targetGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	targetGroup.name = "Target";
	var targetGroupContent = targetGroup.property("ADBE Vectors Group");
	var ellipse = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse("ADBE Vector Ellipse Size").setValue([15,15]);
	var ellipse2 = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse2("ADBE Vector Ellipse Size").setValue([1,1]);
	var targetStroke = targetGroupContent.addProperty("ADBE Vector Graphic - Stroke");
	targetStroke("ADBE Vector Stroke Color").setValue([0.1,0.1,0.1,1]);
	targetStroke("ADBE Vector Stroke Width").setValue(2);


	var displayGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	displayGroup.name = "Display";
	displayGroup.property("ADBE Vector Transform Group").property("ADBE Vector Group Opacity").setValue(50);
	//stretch group
	var stretchBoneGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	stretchBoneGroup.name = "Link";
	var stretchBoneContent = stretchBoneGroup.property("ADBE Vectors Group");
	var star = stretchBoneContent.addProperty("ADBE Vector Shape - Star");
	star("ADBE Vector Star Type").setValue(2);
	star("ADBE Vector Star Points").setValue(3);
	star("ADBE Vector Star Outer Radius").setValue(20);
	star("ADBE Vector Star Outer Roundess").setValue(100);

	var roundExp = '//Duik.structure.roundness\n' +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) value;\n' +
				'else\n' +
				'{\n' +
				'function isBone(layer)\n' +
				'{\n' +
				'var ok = false;\n' +
				'try { layer.content("Structure Element"); ok = true;}\n' +
				'catch (e) { ok = false;}\n' +
				'return ok;\n' +
				'}\n' +
				'if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child)\n' +
				'{\n' +
				'for (var i = thisComp.numLayers  ; i > 0 ; i--)\n' +
				'{\n' +
				'if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n' +
				'{\n' +
				'child = thisComp.layer(i);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (child) break;\n' +
				'}\n' +
				'}\n' +
				'}\n' +
				'if (child)\n' +
				'{\n' +
				'var A = child.toWorld(child.anchorPoint);\n' +
				'var B = thisLayer.toWorld(thisLayer.anchorPoint);\n' +
				'var dist = length(A,B);\n' +
				'if (dist < 20) dist = 20;\n' +
				'var s = content("Structure Element").transform.scale[0];\n' +
				'value/(dist/60)*s/80;\n' +
				'}\n' +
				'else value;\n' +
				'}';

	star("ADBE Vector Star Outer Roundess").expression = roundExp;

	var stretchBoneFill = stretchBoneContent.addProperty("ADBE Vector Graphic - Fill");
	stretchBoneFill("ADBE Vector Fill Color").expression = '//Duik.structure.color\neffect("Structure")(4);';
	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Anchor").setValue([0,10]);

	var scaExpr = "//Duik.structure.stretch\n" +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) [0,0];\n' +
				'else\n' +
				'{\n' +
				"var X = 100;\n" +
				"var Y = 60;\n" +
				"function isBone(layer)\n" +
				"{\n" +
				"var ok = false;\n" +
				"try { layer.content(\"Structure Element\"); ok = true;}\n" +
				"catch (e) { ok = false;}\n" +
				"return ok;\n" +
				"}\n" +
				"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child)\n" +
				"{\n" +
				"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
				"{\n" +
				"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
				"{\n" +
				"child = thisComp.layer(i);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (child) break;\n" +
				"}\n" +
				"}\n" +
				"}\n" +
				"if (child)\n" +
				"{\n" +
				"var A = child.toWorld(child.anchorPoint);\n" +
				"var B = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
				"var dist = length(A,B);\n" +
				"Y = dist/30*100;\n" +
				"}\n" +
				"[X,Y*100/content(\"Structure Element\").transform.scale[1]];\n" +
				'}';

	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Scale").expression = scaExpr;

	var rotExpr = "//Duik.structure.orientation\n" +
			'var child = null;\n' +
			'var childIndex = -1;\n' +
			'try { child = effect("Structure")(3);childIndex = child.index || effect("Structure")(2) == 0}\n' +
			'catch (e) {}\n' +
			'if(!enabled || childIndex == thisLayer.index) value;\n' +
			'else\n' +
			'{\n' +
			"var R = 45;\n" +
			"function isBone(layer)\n" +
			"{\n" +
			"var ok = false;\n" +
			"try { layer.content(\"Structure Element\"); ok = true;}\n" +
			"catch (e) { ok = false;}\n" +
			"return ok;\n" +
			"}\n" +
			"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child)\n" +
			"{\n" +
			"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
			"{\n" +
			"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
			"{\n" +
			"child = thisComp.layer(i);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (child) break;\n" +
			"}\n" +
			"}\n" +
			"}\n" +
			"var result = value;\n" +
			"var layer = thisLayer;\n" +
			"while (layer.hasParent)\n" +
			"{\n" +
			"layer = layer.parent;\n" +
			"result = result - layer.rotation;\n" +
			"}\n" +
			"if (child)\n" +
			"if (child.index != index)\n" +
			"{\n" +
			"C = child.toWorld(child.anchorPoint);\n" +
			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
			"var vec = O-C;\n" +
			"var angle = Math.atan2(vec[1], vec[0]);\n" +
			"var ik = radiansToDegrees(angle);\n" +
			"result += (ik-90-rotation)\n" +
			"}\n" +
			"result;\n" +
			"}";

	elementGroup.property("ADBE Vector Transform Group").property("ADBE Vector Rotation").expression = rotExpr;

	var editModeGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	editModeGroup.name = "Edit Mode";
	var editModeContent = editModeGroup.property("ADBE Vectors Group");
	var circle = editModeContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([40,40]);

	var editModeExpr = '//Duik.structure.editMode\n' +
					'var child = null;\n' +
					'for (var i = 1 ; i <= thisComp.numLayers ; i++)\n' +
					'{\n' +
					'if (i != thisLayer.index && thisComp.layer(i).hasParent)\n' +
					'if (thisComp.layer(i).parent.index == thisLayer.index) {child = thisComp.layer(i); break;}\n' +
					'}\n' +
					'if (child) [0,0];\n' +
					'else value;';

	circle("ADBE Vector Ellipse Size").expression = editModeExpr;

	var editModeFill = editModeContent.addProperty("ADBE Vector Graphic - Fill");
	editModeFill("ADBE Vector Fill Color").setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);

	element.guideLayer = true;

	//group
	DuAEF.Dugr.addLayerToGroup(element,"Structures");

	return element;
}

//Low-level undocumented function
DuAEF.Duik.Structure.isStructure = function (layer)
{
	var structureEffect = layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT);
	if (structureEffect) return true;
	else return false;
}

/**
 * Gets structures in the comp. If some layers are selected, uses selectionMode, else returns all structure elements found.
 * @memberof DuAEF.Duik
 * @param {CompItem}	comp	- The composition where to get the structures
 * @param {int} [structureSelectionMode=DuAEF.Duik.structureSelectionMode.STRUCTURE]	- The selection mode. One of {@link DuAEF.Duik.structureSelectionMode}
 * @return {Structure[]}	The structures. If selectionMode is DuAEF.Duik.structureSelectionMode.ELEMENT, will be one structure with all elements found
 */
DuAEF.Duik.Structure.getStructures = function (comp,selectionMode)
{
	if (selectionMode == undefined) selectionMode = DuAEF.Duik.structureSelectionMode.STRUCTURE;
	var layers = comp.selectedLayers;
	var i = 0;
	var m = layers.length-1;
	if (selectionMode == DuAEF.Duik.structureSelectionMode.ALL)
	{
		layers = comp.layers;
		selectionMode = DuAEF.Duik.structureSelectionMode.STRUCTURE;
		i = 1;
		m = layers.length;
	}

	var structures = [];
	var indexed = [];

	if (layers.length == 0) return structures;

	var structure = new Structure();

	for ( i ; i <= m ; i++)
	{
		var layer = layers[i];
		if (!DuAEF.Duik.Structure.isStructure(layer)) continue;
		if (DuAEF.DuJS.Array.indexOf(indexed,layer.index) >= 0) continue;

		indexed.push(layer.index);

		if (selectionMode == DuAEF.Duik.structureSelectionMode.ELEMENT)
		{
			structure.elements.push(layer);
			continue;
		}
		var structure = new Structure();
		structure.elements.push(layer);
		//get children
		if (selectionMode == DuAEF.Duik.structureSelectionMode.CHILDREN || selectionMode == DuAEF.Duik.structureSelectionMode.STRUCTURE)
		{
			//for all layers in the comp, get child
			var childLayer = layer;
			while (childLayer != null)
			{
				var childIndex = childLayer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;
				if (childIndex == childLayer.index) break;
				var currentIndex = childLayer.index;
				childLayer = null;
				//get child
				if (childIndex != 0)
				{
					var child = comp.layer(childIndex);
					//check if it's a structure element
					if (DuAEF.Duik.Structure.isStructure(child))
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						continue;
					}
				}
				//search child
				for (var j = 1 ; j <= comp.layers.length ; j++)
				{
					var child = comp.layer(j);
					if (child.parent == null) continue;
					if (DuAEF.Duik.Structure.isStructure(child) && child.parent.index == currentIndex)
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						break;
					}
				}
			}
		}

		//get parents
		if (selectionMode == DuAEF.Duik.structureSelectionMode.STRUCTURE)
		{
			var parentLayer = layer;
			while (parentLayer != null)
			{
				var testParent = parentLayer.parent;
				var childIndex = parentLayer.index;

				if (testParent == null) break;
				else if (!DuAEF.Duik.Structure.isStructure(testParent)) break;

				var testIndex = testParent.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;

				parentLayer = null;

				if (testIndex == testParent.index) break;
				else if (testIndex == 0 || testIndex == childIndex)
				{
					structure.elements.unshift(testParent);
					parentLayer = testParent;
					indexed.push(testParent.index);
				}
			}
		}

		structures.push(structure);

	}

	if (selectionMode == DuAEF.Duik.structureSelectionMode.ELEMENT) structures.push(structure);

	return structures;
}

/**
* Automations
* @namespace
* @memberof DuAEF.DUIK
*/
DuAEF.Duik.Automations = {};

/**
* Adds a list on a property
 * @memberof DuAEF.Duik.Automations
* @param {Property} prop - The Property
*/
DuAEF.Duik.Automations.list = function (prop)
{
	if (prop == undefined) throw "Missing Param 1: list needs a Property";
	if (prop.propertyType != PropertyType.PROPERTY) throw "This is not a Property (maybe a PropertyGroup?)";
	if (!prop.canVaryOverTime) throw "This property is not animatable";
	if (!prop.canSetExpression) throw "This property can not set expressions";

	var dim = DuAEF.DuAE.Property.getDimensions(prop);

	var layer = DuAEF.DuAE.Property.getLayer(prop);
	var comp = layer.containingComp;

	layer.selected = true;
	if (dim == 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_LIST);
	else if (dim == 2)layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_LIST);
	else if (dim == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_LIST);
	else { layer.selected = false; return;}
	layer.selected = false;


	var effect = layer.effect("List");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.name + ' List',layer);

	//set animation with expression
	var anim = DuAEF.DuAE.Property.getAnim(prop,false);
	if (anim) DuAEF.DuAE.Property.setAnim(effect(2),anim,0,true,true,true);
	DuAEF.DuAE.Property.removeAnim(prop);

	prop.expression =  "//Duik.list\r\n" +
	"var fx = effect(\"" + effect.name + "\");\n" +
	"var v1 = fx(2);\n" +
	"var w1 = fx(3);\n" +
	"var v2 = fx(6);\n" +
	"var w2 = fx(7);\n" +
	"var v3 = fx(10);\n" +
	"var w3 = fx(11);\n" +
	"var v4 = fx(14);\n" +
	"var w4 = fx(15);\n" +
	"var v5 = fx(18);\n" +
	"var w5 = fx(19);\n" +
	"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}

/**
 * Adds a wiggle to a property
 * @memberof DuAEF.Duik.Automations
 * @param {Property}	prop 				- The property.
 * @param {boolean}		[separateDimensions] 	- Set to true to separate the dimensions (to adjust amplitude and frequency) if the property is multi-dimensionnal.
 * @param {PropertyGroup|null}	[effect]	- A wiggle effect already created by Duik to use as a controller for this wiggle
 * @return {PropertyGroup} The effect created (or provided)
 */
DuAEF.Duik.Automations.wiggle = function (prop,separateDimensions,effect)
{
	if (separateDimensions == undefined) separateDimensions = false;
	if (effect == undefined) effect = null;
	if (!prop) return effect;
	if (prop.propertyType != PropertyType.PROPERTY) return effect;
	if (!prop.canVaryOverTime) return effect;
	if (!prop.canSetExpression) return effect;

	//dimensions
	var dimensions = DuAEF.DuAE.Property.getDimensions(prop);
	var layer = DuAEF.DuAE.Property.getLayer(prop);
	var comp = layer.containingComp;

	if (effect == null)
	{
		layer.selected = true;
		if (!separateDimensions && dimensions > 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_MULTIWIGGLE);
		else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_WIGGLE);
		else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_WIGGLE);
		else layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_WIGGLE);
		layer.selected = false;

		effect = layer.effect("Wiggle");
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.name + ' Wiggle',layer);
	}

	var compEffect = DuAEF.DuAE.Property.getComp(effect);
	var sameComp = compEffect.name == comp.name;

	if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.ONED_MULTIWIGGLE) effect(3).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.THREED_WIGGLE) effect(13).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.TWOD_WIGGLE) effect(9).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.ONED_WIGGLE) effect(3).setValue(comp.duration);

	var effectLink = "var fx = " + DuAEF.DuAE.Property.getExpressionLink(effect,sameComp);

	if (!separateDimensions && dimensions > 1)
	{
		prop.expression = "//Duik.1DMultiWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"linked = fx(4).value;\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"result = [];\n" +
				"if(linked) while (result.length < value.length) result.push(w[0]);\n" +
				"else result = w;\n" +
				"result + value - valueAtTime(0);";
	}
	else if (dimensions == 3)
	{
		prop.expression = "//Duik.3DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Zfreq = fx(11);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"Zamp = fx(10);\n" +
				"loop = fx(13);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1],Z1[2]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1],Z2[2]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 2)
	{
	 	prop.expression = "//Duik.2DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"loop = fx(9);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 1)
	{
		prop.expression = "//Duik.1DWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}

	return effect;
}
