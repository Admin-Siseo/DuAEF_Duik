/*
DuikLib
Library with Duik tools.
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

__Contributors:__

	Nicolas Dufresne - Lead developer
	Kevin Masson - Developer

__Thanks to:__

	Dan Ebberts - Writing the first IK Expressions
	Eric Epstein - making the IK's work with 3D Layers
	Kevin Schires – Including images in the script
	Matias Poggini – Bezier IK feature
	Eric Epstein - Making the IK's work with 3D Layers
	Assia Chioukh and Quentin Saint-Georges – User Guides composition
	Motion Cafe – Ideas and feedback
	Fous d’anim – Ideas and feedback
	All 258 Duik 15 indiegogo backers for making this libDuik possible!


This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* Constructs a Structure
* @class Structure
* @classdesc A Structure.
* @property {Layer[]} elements - The elements of the structure, sorted by their parenting, root at 0
*/
function Structure()
{
	this.elements = [];
	this.editModeRegExp = / \|StructureElementChildren:([\d,]*)\|/;
}

/**
* Sets a new display size for the structure
* @memberof Structure
* @param {int} [size] - The element size, a percentage. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
*/
Structure.prototype.setSize = function (size)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}
	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(2).setValue(size);
	}
}

/**
* Sets a new display color for the structure
* @memberof Structure
* @param {float[]} color - The color
*/
Structure.prototype.setColor = function (color)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(color);
	}
}

/**
* Toggles the edit mode
* @memberof Structure
*/
Structure.prototype.toggleEditMode = function (color)
{
	if (this.elements.length == 0) return;

	var setEditMode = !this.editModeRegExp.test(this.elements[0].comment);

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.toggleElementEditMode(i,setEditMode)
	}
}

/**
* Toggles the edit mode of one element in the structure
* @memberof Structure
* @param {int} elementIndex - The index of the element to toggle in the Structure.elements Array
* @param {boolean} setEditMode - true to turn on edit mode, false to turn it off.
*/
Structure.prototype.toggleElementEditMode = function (elementIndex,setEditMode)
{
	var element = this.elements[elementIndex];
	var comp = element.containingComp;
	var already = this.editModeRegExp.test(element.comment);

	if (setEditMode && !already)
	{
		var children = DuAEF.DuAE.Layer.getChildren(element);
		element.comment = element.comment + ' |StructureElementChildren:';
		for (var j = 0 ; j < children.length ; j++)
		{
			var child = children[j];
			element.comment = element.comment + child.index;
			if (j < children.length -1) element.comment = element.comment + ',';
			child.parent = null;
		}
		element.comment = element.comment + "|";
		element.name = '=EDIT= ' + element.name;
	}
	else if (already)
	{
		var match = this.editModeRegExp.exec(element.comment);
		if (match.length == 2)
		{
			var indices = match[1].split(',');
			//reparent
			if (indices.length > 0)
			{
				for (var i = 0 ; i < indices.length ; i++)
				{
					var index = parseInt(indices[i]);
					if (isNaN(index)) continue;
					comp.layer(index).parent = element;
				}
			}
			//remove comment
			element.comment = element.comment.replace(match[0],'');
			element.name = element.name.replace('=EDIT= ','');
		}
	}
}

/**
* Toggles visibility of the structure
* @memberof Structure
*/
Structure.prototype.showHide = function ()
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	var show = !this.elements[0].enabled;

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.elements[i].enabled = show;
	}
}

/**
* Duik tools
* @namespace
* @memberof DuAEF
*/
DuAEF.Duik = {};

//Initialize
(function ()
{
	//structures
	#include "pseudoEffects/duik_structure.ffx.jsxinc"
	duik_structure = DuAEF.DuBinary.toFile(duik_structure);
	//list
	#include "pseudoEffects/duik_1d_list.ffx.jsxinc"
	duik_1d_list = DuAEF.DuBinary.toFile(duik_1d_list);
	#include "pseudoEffects/duik_2d_list.ffx.jsxinc"
	duik_2d_list = DuAEF.DuBinary.toFile(duik_2d_list);
	#include "pseudoEffects/duik_3d_list.ffx.jsxinc"
	duik_3d_list = DuAEF.DuBinary.toFile(duik_3d_list);
	//wiggle
	#include "pseudoEffects/duik_1d_wiggle.ffx.jsxinc"
	duik_1d_wiggle = DuAEF.DuBinary.toFile(duik_1d_wiggle);
	#include "pseudoEffects/duik_1d_multiwiggle.ffx.jsxinc"
	duik_1d_multiwiggle = DuAEF.DuBinary.toFile(duik_1d_multiwiggle);
	#include "pseudoEffects/duik_2d_wiggle.ffx.jsxinc"
	duik_2d_wiggle = DuAEF.DuBinary.toFile(duik_2d_wiggle);
	#include "pseudoEffects/duik_3d_wiggle.ffx.jsxinc"
	duik_3d_wiggle = DuAEF.DuBinary.toFile(duik_3d_wiggle);
	//swing
	#include "pseudoEffects/duik_1d_swing.ffx.jsxinc"
	duik_1d_swing = DuAEF.DuBinary.toFile(duik_1d_swing);
	#include "pseudoEffects/duik_2d_swing.ffx.jsxinc"
	duik_2d_swing = DuAEF.DuBinary.toFile(duik_2d_swing);
	#include "pseudoEffects/duik_3d_swing.ffx.jsxinc"
	duik_3d_swing = DuAEF.DuBinary.toFile(duik_3d_swing);
	#include "pseudoEffects/duik_spatial_swing.ffx.jsxinc"
	duik_spatial_swing = DuAEF.DuBinary.toFile(duik_spatial_swing);
	//Wheel
	#include "pseudoEffects/duik_wheel.ffx.jsxinc"
	duik_wheel = DuAEF.DuBinary.toFile(duik_wheel);
	//Effector
	#include "pseudoEffects/duik_effector.ffx.jsxinc"
	duik_effector = DuAEF.DuBinary.toFile(duik_effector);
	//Spring
	#include "pseudoEffects/duik_1d_spring.ffx.jsxinc"
	duik_1d_spring = DuAEF.DuBinary.toFile(duik_1d_spring);
	#include "pseudoEffects/duik_multid_spring.ffx.jsxinc"
	duik_multid_spring = DuAEF.DuBinary.toFile(duik_multid_spring);
	#include "pseudoEffects/duik_spatial_spring.ffx.jsxinc"
	duik_spatial_spring = DuAEF.DuBinary.toFile(duik_spatial_spring);
	//Blink
	#include "pseudoEffects/duik_1d_blink.ffx.jsxinc"
	duik_1d_blink = DuAEF.DuBinary.toFile(duik_1d_blink);
	#include "pseudoEffects/duik_2d_blink.ffx.jsxinc"
	duik_2d_blink = DuAEF.DuBinary.toFile(duik_2d_blink);
	#include "pseudoEffects/duik_3d_blink.ffx.jsxinc"
	duik_3d_blink = DuAEF.DuBinary.toFile(duik_3d_blink);
	#include "pseudoEffects/duik_color_blink.ffx.jsxinc"
	duik_color_blink = DuAEF.DuBinary.toFile(duik_color_blink);
	//Paint Rig
	#include "pseudoEffects/duik_paint_rig.ffx.jsxinc"
	duik_paint_rig = DuAEF.DuBinary.toFile(duik_paint_rig);
	//Motion Trail
	#include "pseudoEffects/duik_motion_trail.ffx.jsxinc"
	duik_motion_trail = DuAEF.DuBinary.toFile(duik_motion_trail);

	/**
	 * The pseudo effects needed by Duik
	 * @enum {File}
	 * @readonly
	 */
	DuAEF.Duik.pseudoEffects =
	{
		//Motion trail
		MOTION_TRAIL: duik_motion_trail,
		//Paint Rig
		PAINT_RIG: duik_paint_rig,
		//Blink
		COLOR_BLINK: duik_color_blink,
		ONED_BLINK: duik_1d_blink,
		TWOD_BLINK: duik_2d_blink,
		THREED_BLINK: duik_3d_blink,
		//Spring
		ONED_SPRING: duik_1d_spring,
		MULTID_SPRING: duik_multid_spring,
		SPATIAL_SPRING: duik_spatial_spring,
		//Effector
		EFFECTOR: duik_effector,
		//Wheel
		WHEEL: duik_wheel,
		//Swing
		ONED_SWING: duik_1d_swing,
		SPATIAL_SWING: duik_spatial_swing,
		TWOD_SWING: duik_2d_swing,
		THREED_SWING: duik_3d_swing,
		//wiggle
		ONED_WIGGLE: duik_1d_wiggle,
		ONED_MULTIWIGGLE: duik_1d_multiwiggle,
		TWOD_WIGGLE: duik_2d_wiggle,
		THREED_WIGGLE: duik_3d_wiggle,
		//list
		ONED_LIST: duik_1d_list,
		TWOD_LIST: duik_2d_list,
		THREED_LIST: duik_3d_list,
		//structures
		STRUCTURE_ELEMENT: duik_structure
	};

	/**
	 * The pseudo effects match names
	 * @enum {string}
	 * @readonly
	 */
	DuAEF.Duik.pseudoEffectsMatchNames =
	{
		//Motion trail
		MOTION_TRAIL: "Pseudo/DUIK motion trail",
		//Paint Rig
		PAINT_RIG: "Pseudo/DUIK paint rig",
		//Blink
		COLOR_BLINK: "Pseudo/DUIK color blink",
		ONED_BLINK: "Pseudo/DUIK 1d blink",
		TWOD_BLINK: "Pseudo/DUIK 2d blink",
		THREED_BLINK: "Pseudo/DUIK 3d blink",
		//Spring
		ONED_SPRING: "Pseudo/DUIK 1d spring",
		MULTID_SPRING: "Pseudo/DUIK multid spring",
		SPATIAL_SPRING: "Pseudo/DUIK spatial spring",
		//Effector
		EFFECTOR: "Pseudo/DUIK effector",
		//Wheel
		WHEEL: "Pseudo/DUIK wheel",
		//Swing
		ONED_SWING: "Pseudo/DUIK 1d swing",
		SPATIAL_SWING: "Pseudo/DUIK spatial swing",
		TWOD_SWING: "Pseudo/DUIK 2d swing",
		THREED_SWING: "Pseudo/DUIK 3d swing",
		//wiggle
		ONED_WIGGLE: "Pseudo/DUIK 1d wiggle",
		ONED_MULTIWIGGLE: "Pseudo/DUIK 1d multiwiggle",
		TWOD_WIGGLE: "Pseudo/DUIK 2d wiggle",
		THREED_WIGGLE: "Pseudo/DUIK 3d wiggle",
		//list
		ONED_LIST: "Pseudo/DUIK 1d list",
		TWOD_LIST: "Pseudo/DUIK 2d list",
		THREED_LIST: "Pseudo/DUIK 3d list",
		//structures
		STRUCTURE_ELEMENT: "Pseudo/DUIK structure"
	};

	/**
	 * Predefined sizes
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.sizes =
	{
		SMALL: 0,
		MEDIUM: 1,
		LARGE: 2,
		CUSTOM: 3
	};

	/**
	 * How to get structures depending on selection<br />
	 * All structure, only children elements, or only selected element
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.structureSelectionMode =
	{
		STRUCTURE: 0,
		CHILDREN: 1,
		ELEMENT: 2,
		ALL: 3
	}

	/**
	* Size hint of structure elements
	* @type {int}
	* @default DuAEF.Duik.sizes.SMALL
	*/
	DuAEF.Duik.structureSizeHint = DuAEF.Duik.sizes.SMALL;
	/**
	* The default size for new structures if structureSizeHint is DuAEF.Duik.sizes.CUSTOM
	* @type {int}
	* @default 100
	*/
	DuAEF.Duik.structureSize = 100;
	/**
	* The default color for new structures
	* @type {float[]}
	* @default DuAEF.DuJS.Color.Colors.RANDOM
	*/
	DuAEF.Duik.structureColor = DuAEF.DuJS.Color.Colors.RANDOM

})();

/**
* Structures
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Structure = {};

/**
 * Creates a structure in a composition
 * @memberof DuAEF.Duik
 * @param {int}		num	- The number of elements of the structure
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {string}	[name="Name"]	- The name of the structure (used as layer names)
 * @return {Structure|null}	The Structure or null if there is no active composition
 */
DuAEF.Duik.Structure.addStructure = function (num,comp,name)
{
	if (name === undefined) name = "Name";

	//end
	num++;

	//structure
	var structure = {};
	structure.elements = [];

	//elements length
	var length = comp.width/(num+1);

	var prevElement = null;
	var color = DuAEF.Duik.structureColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM)
	{
		color = DuAEF.DuJS.Color.random();
	}

	for (var i = 0 ; i < num ; i++)
	{
		var end = i == num-1;
		var element = DuAEF.Duik.Structure.addStructureElement(comp,color);
		if (end)
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S-End " + name, comp);
		}
		else
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S " + name, comp);
		}

		if (prevElement)
		{
			element.parent = prevElement;
			element.transform.position.setValue([length,0]);
		}
		else
		{
			element.transform.position.setValue([length,comp.height/2]);
		}
		prevElement = element;
		structure.elements.push(element);
	}
	//links and layer selection
	for (var i = 0;i < structure.elements.length ; i++)
	{
		if (i == structure.elements.length - 1)
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i].index);
			structure.elements[i].selected = false;
		}
		else
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i+1].index);
		}
	}
	structure.elements[0].selected = true;

	return structure;
}

/**
 * Creates an element for a structure in a composition
 * @memberof DuAEF.Duik
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {float[]}	[color=[1,0.764,0.764,1]]		- The color of the element, [R,G,B,A] Array from 0.0 to 1.0
 * @param {float}	[size] 		- The element size, un percent. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
 * @return {ShapeLayer}	The element
 */
DuAEF.Duik.Structure.addStructureElement = function (comp,color,size)
{
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}

	if (!color)
	{
		color = DuAEF.Duik.structureColor;
		if (color == DuAEF.DuJS.Color.Colors.RANDOM)
		{
			color = DuAEF.DuJS.Color.random();
		}
	}


	//======= CREATE ELEMENT USING SHAPE LAYER =======
	var element = comp.layers.addShape();
	//add effect

	element.applyPreset(DuAEF.Duik.pseudoEffects.STRUCTURE_ELEMENT);
	element.effect("Structure")(2).setValue(size);
	element.effect("Structure")(4).setValue(color);

	//bone group
	var elementGroup = element("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	elementGroup.name = "Structure Element";
	elementGroup("ADBE Vector Transform Group")("ADBE Vector Scale").expression = '//Duik.structure.size\nif(!enabled) value;\nelse\n{\nvar s = effect("Structure")(2);\n[s,s];\n}';
	//target group
	var targetGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	targetGroup.name = "Target";
	var targetGroupContent = targetGroup.property("ADBE Vectors Group");
	var ellipse = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse("ADBE Vector Ellipse Size").setValue([15,15]);
	var ellipse2 = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse2("ADBE Vector Ellipse Size").setValue([1,1]);
	var targetStroke = targetGroupContent.addProperty("ADBE Vector Graphic - Stroke");
	targetStroke("ADBE Vector Stroke Color").setValue([0.1,0.1,0.1,1]);
	targetStroke("ADBE Vector Stroke Width").setValue(2);


	var displayGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	displayGroup.name = "Display";
	displayGroup.property("ADBE Vector Transform Group").property("ADBE Vector Group Opacity").setValue(50);
	//stretch group
	var stretchBoneGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	stretchBoneGroup.name = "Link";
	var stretchBoneContent = stretchBoneGroup.property("ADBE Vectors Group");
	var star = stretchBoneContent.addProperty("ADBE Vector Shape - Star");
	star("ADBE Vector Star Type").setValue(2);
	star("ADBE Vector Star Points").setValue(3);
	star("ADBE Vector Star Outer Radius").setValue(20);
	star("ADBE Vector Star Outer Roundess").setValue(100);

	var roundExp = '//Duik.structure.roundness\n' +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) value;\n' +
				'else\n' +
				'{\n' +
				'function isBone(layer)\n' +
				'{\n' +
				'var ok = false;\n' +
				'try { layer.content("Structure Element"); ok = true;}\n' +
				'catch (e) { ok = false;}\n' +
				'return ok;\n' +
				'}\n' +
				'if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child)\n' +
				'{\n' +
				'for (var i = thisComp.numLayers  ; i > 0 ; i--)\n' +
				'{\n' +
				'if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n' +
				'{\n' +
				'child = thisComp.layer(i);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (child) break;\n' +
				'}\n' +
				'}\n' +
				'}\n' +
				'if (child)\n' +
				'{\n' +
				'var A = child.toWorld(child.anchorPoint);\n' +
				'var B = thisLayer.toWorld(thisLayer.anchorPoint);\n' +
				'var dist = length(A,B);\n' +
				'if (dist < 20) dist = 20;\n' +
				'var s = content("Structure Element").transform.scale[0];\n' +
				'value/(dist/60)*s/80;\n' +
				'}\n' +
				'else value;\n' +
				'}';

	star("ADBE Vector Star Outer Roundess").expression = roundExp;

	var stretchBoneFill = stretchBoneContent.addProperty("ADBE Vector Graphic - Fill");
	stretchBoneFill("ADBE Vector Fill Color").expression = '//Duik.structure.color\neffect("Structure")(4);';
	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Anchor").setValue([0,10]);

	var scaExpr = "//Duik.structure.stretch\n" +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) [0,0];\n' +
				'else\n' +
				'{\n' +
				"var X = 100;\n" +
				"var Y = 60;\n" +
				"function isBone(layer)\n" +
				"{\n" +
				"var ok = false;\n" +
				"try { layer.content(\"Structure Element\"); ok = true;}\n" +
				"catch (e) { ok = false;}\n" +
				"return ok;\n" +
				"}\n" +
				"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child)\n" +
				"{\n" +
				"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
				"{\n" +
				"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
				"{\n" +
				"child = thisComp.layer(i);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (child) break;\n" +
				"}\n" +
				"}\n" +
				"}\n" +
				"if (child)\n" +
				"{\n" +
				"var A = child.toWorld(child.anchorPoint);\n" +
				"var B = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
				"var dist = length(A,B);\n" +
				"Y = dist/30*100;\n" +
				"}\n" +
				"[X,Y*100/content(\"Structure Element\").transform.scale[1]];\n" +
				'}';

	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Scale").expression = scaExpr;

	var rotExpr = "//Duik.structure.orientation\n" +
			'var child = null;\n' +
			'var childIndex = -1;\n' +
			'try { child = effect("Structure")(3);childIndex = child.index || effect("Structure")(2) == 0}\n' +
			'catch (e) {}\n' +
			'if(!enabled || childIndex == thisLayer.index) value;\n' +
			'else\n' +
			'{\n' +
			"var R = 45;\n" +
			"function isBone(layer)\n" +
			"{\n" +
			"var ok = false;\n" +
			"try { layer.content(\"Structure Element\"); ok = true;}\n" +
			"catch (e) { ok = false;}\n" +
			"return ok;\n" +
			"}\n" +
			"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child)\n" +
			"{\n" +
			"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
			"{\n" +
			"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
			"{\n" +
			"child = thisComp.layer(i);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (child) break;\n" +
			"}\n" +
			"}\n" +
			"}\n" +
			"var result = value;\n" +
			"var layer = thisLayer;\n" +
			"while (layer.hasParent)\n" +
			"{\n" +
			"layer = layer.parent;\n" +
			"result = result - layer.rotation;\n" +
			"}\n" +
			"if (child)\n" +
			"if (child.index != index)\n" +
			"{\n" +
			"C = child.toWorld(child.anchorPoint);\n" +
			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
			"var vec = O-C;\n" +
			"var angle = Math.atan2(vec[1], vec[0]);\n" +
			"var ik = radiansToDegrees(angle);\n" +
			"result += (ik-90-rotation)\n" +
			"}\n" +
			"result;\n" +
			"}";

	elementGroup.property("ADBE Vector Transform Group").property("ADBE Vector Rotation").expression = rotExpr;

	var editModeGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	editModeGroup.name = "Edit Mode";
	var editModeContent = editModeGroup.property("ADBE Vectors Group");
	var circle = editModeContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([40,40]);

	var editModeExpr = '//Duik.structure.editMode\n' +
					'var child = null;\n' +
					'for (var i = 1 ; i <= thisComp.numLayers ; i++)\n' +
					'{\n' +
					'if (i != thisLayer.index && thisComp.layer(i).hasParent)\n' +
					'if (thisComp.layer(i).parent.index == thisLayer.index) {child = thisComp.layer(i); break;}\n' +
					'}\n' +
					'if (child) [0,0];\n' +
					'else value;';

	circle("ADBE Vector Ellipse Size").expression = editModeExpr;

	var editModeFill = editModeContent.addProperty("ADBE Vector Graphic - Fill");
	editModeFill("ADBE Vector Fill Color").setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);

	element.guideLayer = true;

	//group
	DuAEF.Dugr.addLayerToGroup(element,"Structures");

	return element;
}

//Low-level undocumented function
DuAEF.Duik.Structure.isStructure = function (layer)
{
	var structureEffect = layer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT);
	if (structureEffect) return true;
	else return false;
}

/**
 * Gets structures in the comp. If some layers are selected, uses selectionMode, else returns all structure elements found.
 * @memberof DuAEF.Duik
 * @param {CompItem}	comp	- The composition where to get the structures
 * @param {int} [structureSelectionMode=DuAEF.Duik.structureSelectionMode.STRUCTURE]	- The selection mode. One of {@link DuAEF.Duik.structureSelectionMode}
 * @return {Structure[]}	The structures. If selectionMode is DuAEF.Duik.structureSelectionMode.ELEMENT, will be one structure with all elements found
 */
DuAEF.Duik.Structure.getStructures = function (comp,selectionMode)
{
	if (selectionMode == undefined) selectionMode = DuAEF.Duik.structureSelectionMode.STRUCTURE;
	var layers = comp.selectedLayers;
	var i = 0;
	var m = layers.length-1;
	if (selectionMode == DuAEF.Duik.structureSelectionMode.ALL)
	{
		layers = comp.layers;
		selectionMode = DuAEF.Duik.structureSelectionMode.STRUCTURE;
		i = 1;
		m = layers.length;
	}

	var structures = [];
	var indexed = [];

	if (layers.length == 0) return structures;

	var structure = new Structure();

	for ( i ; i <= m ; i++)
	{
		var layer = layers[i];
		if (!DuAEF.Duik.Structure.isStructure(layer)) continue;
		if (DuAEF.DuJS.Array.indexOf(indexed,layer.index) >= 0) continue;

		indexed.push(layer.index);

		if (selectionMode == DuAEF.Duik.structureSelectionMode.ELEMENT)
		{
			structure.elements.push(layer);
			continue;
		}
		var structure = new Structure();
		structure.elements.push(layer);
		//get children
		if (selectionMode == DuAEF.Duik.structureSelectionMode.CHILDREN || selectionMode == DuAEF.Duik.structureSelectionMode.STRUCTURE)
		{
			//for all layers in the comp, get child
			var childLayer = layer;
			while (childLayer != null)
			{
				var childIndex = childLayer.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;
				if (childIndex == childLayer.index) break;
				var currentIndex = childLayer.index;
				childLayer = null;
				//get child
				if (childIndex != 0)
				{
					var child = comp.layer(childIndex);
					//check if it's a structure element
					if (DuAEF.Duik.Structure.isStructure(child))
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						continue;
					}
				}
				//search child
				for (var j = 1 ; j <= comp.layers.length ; j++)
				{
					var child = comp.layer(j);
					if (child.parent == null) continue;
					if (DuAEF.Duik.Structure.isStructure(child) && child.parent.index == currentIndex)
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						break;
					}
				}
			}
		}

		//get parents
		if (selectionMode == DuAEF.Duik.structureSelectionMode.STRUCTURE)
		{
			var parentLayer = layer;
			while (parentLayer != null)
			{
				var testParent = parentLayer.parent;
				var childIndex = parentLayer.index;

				if (testParent == null) break;
				else if (!DuAEF.Duik.Structure.isStructure(testParent)) break;

				var testIndex = testParent.effect(DuAEF.Duik.pseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;

				parentLayer = null;

				if (testIndex == testParent.index) break;
				else if (testIndex == 0 || testIndex == childIndex)
				{
					structure.elements.unshift(testParent);
					parentLayer = testParent;
					indexed.push(testParent.index);
				}
			}
		}

		structures.push(structure);

	}

	if (selectionMode == DuAEF.Duik.structureSelectionMode.ELEMENT) structures.push(structure);

	return structures;
}

/**
* Animation tools
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Animation = {};

/**
* Automatically adjust the best bezier interpolations on the keyframes
* @param {Property|PropertyInfo} prop - The property containing the keyframes
* @param {boolean} [easeStart=true] - true to ease the first keyframe, false to set it to linear
* @param {boolean} [easeEnd=true] - true to ease the last keyframe, false to set it to linear
* @todo ability to change ease influence (only when velocity is 0?)
* @todo implement a better multidimensionnal algo
*/
DuAEF.Duik.Animation.smartInterpolation = function (prop,easeStart,easeEnd)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (!prop.canVaryOverTime) return;

	//set all keys to linear
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
		if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
	}

	//smooth!
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		var key = prop.selectedKeys[k];
		var easeIn = [];
		var easeOut = [];
		//Compute base velocity
		for (var l = 0;l<prop.keyInTemporalEase(key).length;l++)
		{
			var speedIn = prop.keyInTemporalEase(key)[l].speed;
			var speedOut = prop.keyOutTemporalEase(key)[l].speed;
			var speed = 0;

			if ( Math.abs(speedIn) <= Math.abs(speedOut) ) speed = speedIn;
			else speed = speedOut;
			if (( speedIn > 0 && speedOut < 0 ) || ( speedIn < 0 && speedOut > 0 )) speed = 0;
			if (key == prop.numKeys) speed = 0;
			if (key == 1) speed = 0;

			easeIn.push(new KeyframeEase(speed,33));
			easeOut.push(new KeyframeEase(speed, 33));
		}
		prop.setTemporalEaseAtKey(key,easeIn,easeOut);

		//depending on options, remove ease on first and last keyframes
		if (key == prop.numKeys && !easeEnd)
		{
			prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
			if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
		}
		if (key == 1 && !easeStart)
		{
			prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
			if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
		}
	}

	//Adjust velocities
	for (var k=prop.selectedKeys.length-1;k>=0;k--)
	{
		var key = prop.selectedKeys[k];
		var easeIn = [];
		var easeOut = [];
		if (key < prop.numKeys && key > 1)
		{
			for (var l = 0;l<prop.keyInTemporalEase(key).length;l++)
			{

				var nextSpeed = prop.keyInTemporalEase(key+1)[l].speed;
				var speed = prop.keyOutTemporalEase(key)[l].speed;
				var defaultSpeed = ( prop.valueAtTime(prop.keyTime(key+1),true)-prop.valueAtTime(prop.keyTime(key),true) ) / (prop.keyTime(key+1) - prop.keyTime(key));

				var nextAbsSpeed = Math.abs(nextSpeed);
				var absSpeed = Math.abs(speed);

				var nextDif = nextSpeed - defaultSpeed;
				var dif = speed - defaultSpeed;

				if (speed != 0)
				{
					if (nextAbsSpeed < absSpeed)
					{
						var fix = (1-nextAbsSpeed/absSpeed)*absSpeed;
					}
					else if (nextAbsSpeed != 0)
					{
						var fix = (1-absSpeed/nextAbsSpeed)*absSpeed;
					}

					if (-nextDif > dif) speed += fix;
					else speed -= fix;

				}
				easeIn.push(new KeyframeEase(speed,33));
				easeOut.push(new KeyframeEase(speed, 33));
			}
			prop.setTemporalEaseAtKey(key,easeIn,easeOut);
		}
	}
}

/**
* Creates a motion trail for the layer
* @param {CompItem} [comp] - The comp where to create the trails, can be omitted if you provide a layer
* @param {Layer} [layer] - The layer source of the motion. If not provided, will just create an empty motion trail control
* @param {ShapeLayer|null} [trailLayer] - An existing shape layer containing the trails
* @param {float[]|null} [color] - A color for the motion trail. If not provided, random
* @return {ShapeLayer} The layer containing the motion trail created
*/
DuAEF.Duik.Animation.motionTrail = function (comp,layer,trailLayer,color)
{
	if (comp == undefined && layer == undefined) return;
	if (comp == undefined) comp = layer.containingComp;
	if (color == undefined || color == null) color = DuAEF.DuJS.Color.random();

	//create layer
	if (trailLayer == undefined || trailLayer == null)
	{
		trailLayer = comp.layers.addShape();
		trailLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName('Motion Trails',comp);
	}

	//Effect

	var newEffectName = DuAEF.DuAE.Layer.newUniqueEffectName('Motion trail 1',trailLayer);
	//trailLayer.applyPreset(DuAEF.Duik.pseudoEffects.MOTION_TRAIL);
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(trailLayer,DuAEF.Duik.pseudoEffects.MOTION_TRAIL,DuAEF.Duik.pseudoEffectsMatchNames.MOTION_TRAIL);
	effect.name = newEffectName;

	//create shape
	var trailGroup = trailLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	trailGroup.name = effect.name;
	var trailPath = trailGroup("ADBE Vectors Group").addProperty("ADBE Vector Shape - Group");
	trailPath = trailPath.property("ADBE Vector Shape");
	trailPath.expression = '//Duik.motionTrail\n' +
						'var fx = effect("' + effect.name + '");\n' +
						'var layer = null;\n' +
						'try {layer = fx(1);} catch(e){}\n' +
						'if (layer != null) {\n' +
						'var inFrame = fx(2).value;\n' +
						'var outFrame = fx(3).value;\n' +
						'var method = fx(5).value;\n' +
						'var samples = fx(10).value;\n' +
						'var points = [];\n' +
						'var currentFrame = timeToFrames(time);\n' +
						'if (inFrame > outFrame) inFrame = -inFrame;\n' +
						'else if (inFrame == outFrame) inFrame = -1;\n' +
						'var prevPos = null;\n' +
						'var autoSampleLimit = 1/(20*samples)*(thisComp.width+thisComp.height);\n' +
						'for (var i = currentFrame+outFrame ; i >= currentFrame+inFrame; i--)\n' +
						'{\n' +
						'var t = framesToTime(i);\n' +
						'var pos = layer.toWorld( layer.anchorPoint, t );\n' +
						'var subSamples = 0;\n' +
						'if (method == 2 && prevPos)\n' +
						'{\n' +
						'var step = length(pos,prevPos);\n' +
						'var stepRatio = step/autoSampleLimit;\n' +
						'if (stepRatio > 1) subSamples = Math.floor(stepRatio);\n' +
						'}\n' +
						'else if (method == 3) subSamples = samples;\n' +
						'if (method == 2 || method == 3)\n' +
						'{\n' +
						't = t+thisComp.frameDuration;\n' +
						'for (var j = 0;j < subSamples ; j++)\n' +
						'{\n' +
						't = t-thisComp.frameDuration/subSamples;\n' +
						'var subPos = layer.toWorld( layer.anchorPoint, t );\n' +
						'subPos = subPos - position;\n' +
						'points.push( subPos );\n' +
						'}\n' +
						'}\n' +
						'prevPos = pos;\n' +
						'pos = pos - position;\n' +
						'points.push( pos );\n' +
						'}\n' +
						'createPath(points,[],[], false);\n' +
						'} else value';

	var trailStroke = trailGroup("ADBE Vectors Group").addProperty("ADBE Vector Graphic - Stroke");

	trailStroke('ADBE Vector Stroke Color').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(13);';

	trailStroke('ADBE Vector Stroke Opacity').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(14);';

	trailStroke('ADBE Vector Stroke Width').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(15);';

	//set layer
	if (layer != undefined) effect(1).setValue(layer.index);
	//set color
	effect(13).setValue(color);



	return trailLayer;
}

/**
* Automations
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Automation = {};

/**
* Adds a list on a property
 * @memberof DuAEF.Duik.Automation
* @param {PropertyInfo} prop - The Property
*/
DuAEF.Duik.Automation.list = function (prop)
{
	if (prop == undefined) throw "Missing Param 1: list needs a Property";
	if (!prop.riggable) return;

	var dim = prop.dimensions;

	var layer =prop.layer;
	var comp = layer.containingComp;

	layer.selected = true;
	if (dim == 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_LIST);
	else if (dim == 2)layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_LIST);
	else if (dim == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_LIST);
	else { layer.selected = false; return;}
	layer.selected = false;


	var effect = layer.effect("List");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' List',layer);

	//set animation with expression
	var anim = DuAEF.DuAE.Property.getAnim(prop,false);
	if (anim) DuAEF.DuAE.Property.setAnim(effect(2),anim,0,true,true,true);
	DuAEF.DuAE.Property.removeAnim(prop);

	prop.getProperty().expression =  "//Duik.list\r\n" +
					"var fx = effect(\"" + effect.name + "\");\n" +
					"var v1 = fx(2);\n" +
					"var w1 = fx(3);\n" +
					"var v2 = fx(6);\n" +
					"var w2 = fx(7);\n" +
					"var v3 = fx(10);\n" +
					"var w3 = fx(11);\n" +
					"var v4 = fx(14);\n" +
					"var w4 = fx(15);\n" +
					"var v5 = fx(18);\n" +
					"var w5 = fx(19);\n" +
					"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}

/**
 * Adds a wiggle to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 * @param {boolean}		[separateDimensions] 	- Set to true to separate the dimensions (to adjust amplitude and frequency) if the property is multi-dimensionnal.
 * @param {PropertyGroup|null}	[effect]	- A wiggle effect already created by Duik to use as a controller for this wiggle
 * @return {PropertyGroup} The effect created (or provided)
 */
DuAEF.Duik.Automation.wiggle = function (prop,separateDimensions,effect)
{
	if (separateDimensions == undefined) separateDimensions = false;
	if (effect == undefined) effect = null;
	if (!prop) return effect;
	if (!prop.riggable) return effect;

	//dimensions
	var dimensions = prop.dimensions;
	var layer = prop.layer;
	var comp = layer.containingComp;

	if (effect == null)
	{
		layer.selected = true;
		if (!separateDimensions && dimensions > 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_MULTIWIGGLE);
		else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_WIGGLE);
		else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_WIGGLE);
		else layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_WIGGLE);
		layer.selected = false;

		effect = layer.effect("Wiggle");
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Wiggle',layer);
	}

	var compEffect = DuAEF.DuAE.Property.getComp(effect);
	var sameComp = compEffect.name == comp.name;

	if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.ONED_MULTIWIGGLE) effect(3).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.THREED_WIGGLE) effect(13).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.TWOD_WIGGLE) effect(9).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.pseudoEffectsMatchNames.ONED_WIGGLE) effect(3).setValue(comp.duration);
	//TODO Wiggle for other types of properties
	var effectLink = "var fx = " + DuAEF.DuAE.Property.getExpressionLink(effect,sameComp);

	if (!separateDimensions && dimensions > 1)
	{
		prop.getProperty().expression = "//Duik.1DMultiWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"linked = fx(4).value;\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"result = [];\n" +
				"if(linked) while (result.length < value.length) result.push(w[0]);\n" +
				"else result = w;\n" +
				"result + value - valueAtTime(0);";
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = "//Duik.3DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Zfreq = fx(11);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"Zamp = fx(10);\n" +
				"loop = fx(13);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1],Z1[2]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1],Z2[2]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 2)
	{
	 	prop.getProperty().expression = "//Duik.2DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"loop = fx(9);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = "//Duik.1DWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}

	return effect;
}

/**
 * Adds a swing to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 */
DuAEF.Duik.Automation.swing = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	if (dimensions < 1 || dimensions > 3) return;

	layer.selected = true;
	if (prop.getProperty().isSpatial) layer.applyPreset(DuAEF.Duik.pseudoEffects.SPATIAL_SWING);
	else if (dimensions == 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_SWING);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_SWING);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_SWING);
	layer.selected = false;
	var effect = layer.effect("Swing");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Swing',layer);



	if (prop.getProperty().isSpatial)
	{
		prop.getProperty().expression = 	'//Duik.spatialSwing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = Math.abs(fx(4));\n' +
					'var angle = fx(5)/180*Math.PI;\n' +
					'var result = [0,0];\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'sin = sin*amp;\n' +
					'result = [0,sin];\n' +
					'var x = -sin*Math.sin(angle);\n' +
					'var y = sin*Math.cos(angle);\n' +
					'result = [ x,y ] ;\n' +
					'}\n' +
					'result + value;\n';
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'result + value;';
	}
	else if (dimensions == 2)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result];\n' +
					'else if (axis == 2) result =[result,0];\n' +
					'else if (axis == 3) result =[0,result];\n' +
					'result+value;';
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result,result];\n' +
					'else if (axis == 2) result =[result,0,0];\n' +
					'else if (axis == 3) result =[0,result,0];\n' +
					'else if (axis == 4) result =[0,0,result];\n' +
					'result+value;';
	}
}

/**
 * Automates the rotation of a layer as a wheel
 * @memberof DuAEF.Duik.Automation
 * @param {Layer}	layer - The layer.
* @param {int}	[radius] - The radius of the wheel, in pixels. Will be auto-detected if possible
 */
DuAEF.Duik.Automation.wheel = function (layer,radius)
{
	if (!layer) throw "Missing Param 1: Wheel needs a Layer";
	if (radius == undefined)
	{
		var parent = layer.parent;
		layer.parent = null;
		var rect = layer.sourceRectAtTime(0,false);
		radius = rect.width/2*layer.transform.scale.value[0]/100;
		layer.parent = parent;
	}
	var rotation = layer.transform.rotation;
	if (layer.threeDLayer) rotation = layer.transform.zRotation;

	var effectName = DuAEF.DuAE.Layer.newUniqueEffectName('Wheel',layer);
	layer.selected = true;
	layer.applyPreset(DuAEF.Duik.pseudoEffects.WHEEL);
	layer.selected = false;
	var effect = layer.effect("Wheel");
	effect.name = effectName;
	effect(1).setValue(radius);

	rotation.expression = '//Duik.Wheel\n' +
						'var fx = thisLayer.effect("' + effect.name + '");\n' +
						'var R = fx(1);\n' +
						'var Rev = fx(2);\n' +
						'var curved = fx(3) == 2;\n' +
						'function pos(frame)\n' +
						'{\n' +
						'return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n' +
						'}\n' +
						'var result = 0;\n' +
						'if (R>0)\n' +
						'{\n' +
						'var distance = 0;\n' +
						'if (curved)\n' +
						'{\n' +
						'var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n' +
						'var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n' +
						'for(i=start;i<end;i++)\n' +
						'{\n' +
						'if (pos(i+1)[0] - pos(i)[0] > 0) distance += length(pos(i+1),pos(i));\n' +
						'else distance -= length(pos(i+1),pos(i));\n' +
						'}\n' +
						'}\n' +
						'else\n' +
						'{\n' +
						'distance = pos(timeToFrames(time))[0];\n' +
						'}\n' +
						'result = radiansToDegrees(distance/R);\n' +
						'}\n' +
						'Rev == 1 ? value - result : value + result;';

}

/**
* Links a property to an effector controller
* @param {PropertyInfo} prop - The property to rig
* @param {PropertyGroup|null} [effect] - A Layer expression control used to link to the effector. Will be created on the layer if not provided
* @param {ShapeLayer|null} [ctrlLayer] - The effector layer. will be created if not provided
* @return {object} A custom object with two attributes:<br />
* - effectorLayer: the effector layer
* - effect: the layer expression control on the rigged layer used to link to the effector
*/
DuAEF.Duik.Automation.effector = function (prop,effect,ctrlLayer)
{
	if (effect == undefined) effect = null;
	if (ctrlLayer == undefined) ctrlLayer = null;
	var effector = {};
	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;
	if (!prop) return effector;
	if (!prop.riggable) return effector;

	var layer = prop.layer;
	var comp = layer.containingComp;

	//create effector
	if (ctrlLayer == null)
	{
		ctrlLayer = comp.layers.addShape();
		ctrlLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName("Effector",comp);
		//effect
		ctrlLayer.selected = true;
		layer.applyPreset(DuAEF.Duik.pseudoEffects.EFFECTOR);
		//content
		var centerGroup = ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		centerGroup.name = "Center";
		var centerContent = centerGroup.property("ADBE Vectors Group");
		var centerCircle = centerContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([4,4]);
		var centerFill = centerContent.addProperty("ADBE Vector Graphic - Fill");
		centerFill("ADBE Vector Fill Color").setValue(DuAEF.DuJS.Color.Colors.BLACK);
		centerFill("ADBE Vector Fill Opacity").setValue(50);
		var innerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		innerGroup.name = "Inner";
		var innerContent = innerGroup.property("ADBE Vectors Group");
		var innerCircle = innerContent.addProperty("ADBE Vector Shape - Ellipse");
		innerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.inner\nvar inner = effect("Effector")(1)*2;\n[inner,inner];';
		var innerStroke = innerContent.addProperty("ADBE Vector Graphic - Stroke");
		innerStroke("ADBE Vector Stroke Color").setValue(DuAEF.DuJS.Color.Colors.GREEN);
		var outerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		outerGroup.name = "Outer";
		var outerContent = outerGroup.property("ADBE Vectors Group");
		var outerCircle = outerContent.addProperty("ADBE Vector Shape - Ellipse");
		outerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.outer\nvar outer = effect("Effector")(2)*2;\n[outer,outer];';
		var outerStroke = outerContent.addProperty("ADBE Vector Graphic - Stroke");
		outerStroke("ADBE Vector Stroke Color").setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);
		//unselect
		ctrlLayer.selected = false;
		//set Defaults
		var distance = DuAEF.DuAE.Layer.getDistance(layer,ctrlLayer);
		ctrlLayer.effect("Effector")(1).setValue(distance/4);
		ctrlLayer.effect("Effector")(2).setValue(distance*3/4);
	}

	//create effect
	if (effect == null)
	{
		effect = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Effector',layer);
	}

	//Set effect
	effect(1).setValue(ctrlLayer.index);

	//set expression
	prop.getProperty().expression = '//Duik.effector\n' +
				'var ctrl = null;\n' +
				'var result = value;\n' +
				'try { ctrl = effect("' + effect.name + '")(1) } catch (e) {}\n' +
				'if (ctrl && numKeys >= 2)\n' +
				'{\n' +
				'function p(l){ return l.toWorld(l.anchorPoint) };\n' +
				'try { var fx = ctrl.effect("Effector"); } catch (e) {}\n' +
				'if (fx)\n' +
				'{\n' +
				'var min = fx(1);\n' +
				'var max = fx(2);\n' +
				'var mode = fx(3);\n' +
				'var reverse = fx(4).value;\n' +
				'var t = 0;\n' +
				'var beginTime = key(1).time;\n' +
				'var endTime = key(numKeys).time;\n' +
				'var distance = length ( p(thisLayer), p(ctrl) );\n' +
				'if (mode == 1)\n' +
				'{\n' +
				'if (!reverse) t = linear(distance, min, max, endTime, beginTime);\n' +
				'else t = linear(distance, min, max, beginTime, endTime);\n' +
				'}\n' +
				'else\n' +
				'{\n' +
				'var mid = (min + max)/2;\n' +
				'if (!reverse)\n' +
				'{\n' +
				'if (distance > mid) t = linear(distance, mid, max, endTime, beginTime);\n' +
				'else t = linear(distance, min, mid, beginTime, endTime);\n' +
				'}\n' +
				'else\n' +
				'{\n' +
				'if (distance > mid) t = linear(distance, mid, max, beginTime, endTime);\n' +
				'else t = linear(distance, min, mid, endTime, beginTime);\n' +
				'}\n' +
				'}\n' +
				'result = valueAtTime(t);\n' +
				'}\n' +
				'}\n' +
				'result;\n';

	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;

	return effector;
}

/**
* Adds a spring effect on the property
* @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.spring = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	//search for one dimension effects, to know if we need a "bounce" checkbox
	var bounce = false;
	if (prop.dimensions == 1) bounce = true;

	//check if it's spatial
	var spatial = prop.getProperty().isSpatial;
	var layer = prop.layer;

	var effect = null;

	layer.selected = true;
	if (bounce) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_SPRING);
	else if (spatial) layer.applyPreset(DuAEF.Duik.pseudoEffects.SPATIAL_SPRING);
	else layer.applyPreset(DuAEF.Duik.pseudoEffects.MULTID_SPRING);
	layer.selected = false;
	effect = layer.effect("Spring");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().parentProperty.name + ' Spring',layer);

	if (bounce)
	{
		prop.getProperty().expression = "//Duik.Spring\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					"speedLimit = 0.1;\n" +
					"bounce = fx(3).value;\n\n" +
					"if (numKeys > 1 && elasticity != 0 ){\n" +
					"if (nearestKey(time).index == 1) { value }\n" +
					"else {\n\n" +
					"if (length(velocity) <= speedLimit ) {\n\n" +
					"tempsClefProx = nearestKey(time).time;\n\n" +
					"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
					"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
					"temps = time - tempsDebut;\n\n" +
					"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
					"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
					"if (!bounce) valueAtTime(tempsDebut) + spring;\n\n" +
					"if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
					"if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
					"}\n" +
					"else { value }\n" +
					"}\n" +
					"}\n" +
					"else { value }";
	}
	else if (spatial)
	{
		var toWorldFunc = '';
		if (prop.getProperty().matchName == 'ADBE Position')
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		else
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(value,temps)[0]-thisLayer.toWorld(value,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(value,temps)[1]-thisLayer.toWorld(value,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		prop.getProperty().expression = "//Duik.spring\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					'simulation = fx(3).value;\n' +
					"speedLimit = 0.1;\n" +
					"if (damping == 0) damping = 0.01;\n" +
					"if (elasticity == 0) elasticity = 0.01;\n" +
					"retard = elasticity/damping;\n" +
					"poids = 1/damping/10;\n" +
					"precision = thisComp.frameDuration;\n" +
					toWorldFunc +
					"function worldSpeed(temps) {\n" +
					"return length(worldVelocity(temps));\n" +
					"}\n" +
					'if (simulation == 2)\n' +
					'{\n' +
						"tempsDebut = 0;\n" +
						"tempsRedemarrage = 0;\n" +
						"stop = false;\n" +
						"arrete = false;\n" +
						"for (i=timeToFrames(time);i>=0;i--) {\n" +
						"var instant = framesToTime(i);\n" +
						"var instantSuivant = instant-precision;\n" +
						"if (worldSpeed(instant) == 0 ) {\n" +
						"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" +
						"if (worldSpeed(instantSuivant) !=0 ) {\n" +
						"tempsDebut = instantSuivant;\n" +
						"break;\n" +
						"}\n" +
						"}\n" +
						"}\n" +
						"temps = time-tempsDebut;\n" +
						"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" +
						"valeur = value\n" +
						"if ( frameRedemarre <= retard)\n" +
						"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" +
						"else\n" +
						"valeur = value - worldVelocity(time)*poids;\n" +
						"if (worldSpeed(time) == 0) {\n" +
						"spring = worldVelocity(tempsDebut) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
						"valeur + spring;\n" +
						"}else{ valeur; }\n" +
					'}\n' +
					'else\n' +
					'{\n' +
						"if (numKeys > 1 && elasticity != 0 ){\n" +
						"if (nearestKey(time).index == 1) { value }\n" +
						"else {\n\n" +
						"if (length(velocity) <= speedLimit ) {\n\n" +
						"tempsClefProx = nearestKey(time).time;\n\n" +
						"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
						"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
						"temps = time - tempsDebut;\n\n" +
						"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
						"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
						"valueAtTime(tempsDebut) + spring;\n\n" +
						"}\n" +
						"else { value }\n" +
						"}\n" +
						"}\n" +
						"else { value }\n" +
					'}\n';

	}
	else
	{
		prop.getProperty().expression = "//Duik.Spring\r\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					"speedLimit = 0.1;\n" +
					"if (numKeys > 1 && elasticity != 0 ){\n" +
					"if (nearestKey(time).index == 1) { value }\n" +
					"else {\n\n" +
					"if (length(velocity) <= speedLimit ) {\n\n" +
					"tempsClefProx = nearestKey(time).time;\n\n" +
					"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
					"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
					"temps = time - tempsDebut;\n\n" +
					"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
					"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
					"valueAtTime(tempsDebut) + spring;\n\n" +
					"}\n" +
					"else { value }\n" +
					"}\n" +
					"}\n" +
					"else { value }";
	}
}

/**
* Adds a blink effect on the property
* @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.blink = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	layer.selected = true;
	if (dimensions == 1) layer.applyPreset(DuAEF.Duik.pseudoEffects.ONED_BLINK);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.pseudoEffects.TWOD_BLINK);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.pseudoEffects.THREED_BLINK);
	else if (dimensions == 4) layer.applyPreset(DuAEF.Duik.pseudoEffects.COLOR_BLINK);
	layer.selected = false;

	var effect = layer.effect('Blink');
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Blink',layer);
	DuAEF.DuAE.Property.setValue(effect(1),prop.getProperty().value);

	prop.getProperty().expression = "//Duik.blink\n" +
		'var fx = effect("' + effect.name + '")\n' +
		"var phase = fx(3).value;\n" +
		"var timeOn = fx(4).value;\n" +
		"var offset = fx(5).value;\n" +
		"var valueA = fx(1).value;\n" +
		"var valueB = fx(2).value;\n" +
		"freq= timeToFrames(1)/phase;\n" +
		"var currentFrame = timeToFrames(time+offset/phase/100);\n" +
		"if (currentFrame%freq > freq*timeOn/100) valueB;\n" +
		"else valueA;";
}

/**
* Adds a move away effect on the layer
* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.moveAway = function (layer)
{
	if (layer == undefined) return;
	var effect = layer.Effects.addProperty("ADBE Slider Control");
	effect.name =  DuAEF.DuAE.Layer.newUniqueEffectName('Move away from parent',layer);

	layer.transform.position.expression = "//Duik.moveAway\n" +
						"if (thisLayer.hasParent)\n" +
						"{\n" +
						"thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
						"depl = effect(\"" + effect.name  + "\")(1)\n" +
						"dist = length(parentWorldPos ,thisWorldPos )\n" +
						"coef = (dist+depl)/dist\n" +
						"newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos\n" +
						"thisLayer.parent.fromWorld(newWorldPos)\n" +
						"}\n" +
						"else\n" +
						"{\n" +
						"value\n" +
						"}\n";
}

/**
* Rigs the paint effects found on the layer to animate all the strokes as if there was only one
* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.paintRig = function (layer)
{
	if (layer == undefined) return;

	//if there's no paint effect
	var paintEffect = layer("ADBE Effect Parade")("ADBE Paint");
	if (paintEffect == null) return;

	//add effect
	var newName = DuAEF.DuAE.Layer.newUniqueEffectName('Paint Rig',layer);
	layer.selected = true;
	layer.applyPreset(DuAEF.Duik.pseudoEffects.PAINT_RIG);
	layer.selected = false;
	var effect = layer.effect('Paint Rig');
	effect.name = newName;

	//need to get the paint effect again after addProperty, After Effects bug.......
	var paintEffect = layer("Effects")("ADBE Paint");

	//the first diameter and color
	var defaultDiam = 0;
	var defaultCol = [0,0,0,0];

	//for each stroke
	var nbre = paintEffect.property(2).numProperties;
	for (var j=1;j<=nbre;j++)
	{
		var stroke = paintEffect.property(2).property(j);
		var propStart = stroke.property(4).property(1);
		var propEnd = stroke.property(4).property(2);
		var propCol = stroke.property(4).property(3);
		var propDiam = stroke.property(4).property(4);

		if (defaultDiam == 0)
		{
			defaultDiam = propDiam.value;
			effect(13).setValue(defaultDiam);
			effect(14).setValue(defaultDiam);
		}
		if (defaultCol[3] == 0)
		{
			defaultCol = propCol.value;
			effect(9).setValue(defaultCol);
			effect(10).setValue(defaultCol);
		}

		propStart.expression = '//Duik.PaintRig\n' +
					'var ctrl = effect("' + effect.name + '")(1);\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex\n' +
					'result = ctrl - ((100/total)*(ind-1));\n' +
					'result = result * total;\n' +
					'result;';

		propEnd.expression = '//Duik.PaintRig\n' +
					'var ctrl = effect("' + effect.name + '")(2);\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'result = ctrl - ((100/total)*(ind-1));\n' +
					'result = result * total;\n' +
					'result;';

		propDiam.expression = '//Duik.PaintRig\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var ctrlA = fx(13).value;\n' +
					'var ctrlB = fx(14).value;\n' +
					'var reverse = fx(6).value;\n' +
					'var interpolation =fx(5).value;\n' +
					'var mode = fx(4).value;\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'if (reverse)\n' +
					'{\n' +
					'var t = ctrlA;\n' +
					'ctrlA = ctrlB;\n' +
					'ctrlB = t;\n' +
					'}\n' +
					'var result = ctrlA;\n' +
					'if (mode == 2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
					'}\n' +
					'else if (mode == 3)\n' +
					'{\n' +
					'if (ind < total /2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
					'}\n' +
					'else\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
					'}\n' +
					'}\n' +
					'result;';

		propCol.expression = '//Duik.PaintRig\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var ctrlA = fx(9).value;\n' +
					'var ctrlB = fx(10).value;\n' +
					'var reverse = fx(6).value;\n' +
					'var interpolation = fx(5).value;\n' +
					'var mode = fx(4).value;\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'if (reverse)\n' +
					'{\n' +
					'var t = ctrlA;\n' +
					'ctrlA = ctrlB;\n' +
					'ctrlB = t;\n' +
					'}\n' +
					'var result = ctrlA;\n' +
					'if (mode == 2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
					'}\n' +
					'else if (mode == 3)\n' +
					'{\n' +
					'if (ind < total /2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
					'}\n' +
					'else\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
					'}\n' +
					'}\n' +
					'result;';
	}
}

/**
* Randomize tools
* @namespace
* @memberof DuAEF.Duik.Automation
*/
DuAEF.Duik.Automation.Randomize = {};

/**
* Randomizes the values at current time of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} xMin - X minimum value
* @param {float} xMax - X maximum value
* @param {float} [yMin] - Y minimum value
* @param {float} [yMax] - Y maximum value
* @param {float} [zMin] - Z minimum value
* @param {float} [zMax] - Z maximum value
*/
DuAEF.Duik.Automation.Randomize.properties = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
	if (props == undefined) throw "You must select the properties you want to randomize";
	if (props.length == 0) throw "You must select the properties you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));

	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			var xval = 0;
			var yval = 0;
			var zval = 0;
			//X
			if (x) xval = DuAEF.DuJS.Math.random(xMin,xMax);
			else if (dim == 1) xval = prop.value;
			else xval = prop.value[0];
			//Y
			if (dim == 2 || dim == 3 && y) yval = DuAEF.DuJS.Math.random(yMin,yMax);
			else if (dim == 3 || dim == 2) yval = 0;
			//Z
			if (dim == 3 && z) zval = DuAEF.DuJS.Math.random(zMin,zMax);
			else if (dim == 3) zval = 0;
			//SET VALUE
			var val;
			if (dim == 1) val = xval;
			if (dim == 2) val = [xval,yval];
			if (dim == 3) val = [xval,yval,zval];
			if (fromCurrentVal) val = val + prop.value;
			prop.numKeys ? prop.setValueAtTime(comp.time,val) : prop.setValue(val);
		}
	}
}

/**
* Randomizes the values of the selected keys of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} xMin - X minimum value
* @param {float} xMax - X maximum value
* @param {float} [yMin] - Y minimum value
* @param {float} [yMax] - Y maximum value
* @param {float} [zMin] - Z minimum value
* @param {float} [zMax] - Z maximum value
*/
DuAEF.Duik.Automation.Randomize.selectedKeys = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var xval = 0;
				var yval = 0;
				var zval = 0;
				//X
				if (x) xval = DuAEF.DuJS.Math.random(xMin,xMax);
				else xval = 0;
				//Y
				if (dim == 2 || dim == 3 && y) yval = DuAEF.DuJS.Math.random(yMin,yMax);
				else if (dim == 3 || dim == 2) yval = 0;
				//Z
				if (dim == 3 && z) zval = DuAEF.DuJS.Math.random(zMin,zMax);
				else if (dim == 3) zval = 0;
				//SET VALUE
				var val;
				if (dim == 1) val = xval;
				if (dim == 2) val = [xval,yval];
				if (dim == 3) val = [xval,yval,zval];
				if (fromCurrentVal) val = val + prop.keyValue(key);
				prop.setValueAtKey(key,val);
			}
		}
	}
}

/**
* Randomizes the times of the selected keys of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.selectedKeyTimes = function (props,fromCurrentVal,min,max)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (min != undefined && max != undefined && !isNaN(min) && !isNaN(max));
	if (!x) throw "You must define a randomizing range";

	//array to list keys to be removed
	var krKeys = [];


	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		var krK = [];
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var t = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
				//SET VALUE
				if (fromCurrentVal) r += prop.keyTime(key);
				var oldKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,key);
				krK.push(prop.keyTime(key));
				DuAEF.DuAE.Property.setKey(prop,oldKey,t);
			}
		}
		krKeys.push(krK);
	}

	for (var i = 0 ; i < props.length ; i++)
	{
		var prop = props[i];
		for (var j = 0 ; j < krKeys[i].length ; j++)
		{
			prop.removeKey(prop.nearestKeyIndex(krKeys[i][j]));
		}
	}
}

/**
* Randomizes the start times of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.startTimes = function (layers,fromCurrentVal,min,max)
{
		if (layers == undefined) return;
		if (layers.length == 0 ) return;

		var it = DuAEF.DuAE.getListIterator(layers);

		for (var i = it.min ; i <= it.max ; i++)
		{
			var l = layers[i];
			var comp = l.containingComp;
			var startTime = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.startTime = l.startTime + startTime;
			else l.startTime = startTime;
		}
	}

/**
* Randomizes the in points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.inPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = DuAEF.DuAE.getListIterator(layers);

	for (var i = it.min; i<= it.max;i++)
	{
		var l = layers[i];
		var comp = l.containingComp;
		var inPoint = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.inPoint = l.inPoint + inPoint;
		else l.inPoint = inPoint;
	}
}

/**
* Randomizes the out points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.outPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = DuAEF.DuAE.getListIterator(layers);

	for (var i = it.min; i<= it.max;i++)
	{
		var l = layers[i];
		var comp = l.containingComp;
		var outPoint = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.outPoint = l.outPoint + outPoint;
		else l.outPoint = outPoint;
	}
}

/**
* Randomizes the indices of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum index
* @param {float} max - maximum index
*/
DuAEF.Duik.Automation.Randomize.indices = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = DuAEF.DuAE.getListIterator(layers);

	for (var i = it.min; i<= it.max;i++)
	{
		var l = layers[i];
		var index = parseInt(DuAEF.DuJS.Math.random(min,max));
		if (fromCurrentVal) index = l.index + index;
		if (index == l.index) continue;
		var comp = l.containingComp;
		if (index >= comp.numLayers) l.moveToEnd();
		else if (index < 2) l.moveToBeginning();
		else l.moveBefore(comp.layer(index));
	}
}
