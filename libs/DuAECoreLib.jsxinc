/*
DuAECoreLib
Library with core After Effects tools. Contains the main class of Duduf AE Framework
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

_Contributors:_
Nicolas Dufresne - Lead developer

This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* Constructs a new KeySpatialProperty
* @class KeySpatialProperties
* @classdesc Spatial properties of a {@linkcode KeyFrame}.
* @property {float[]|null}	  [inTangent=null]     - The incoming spatial tangent
* @property {float[]|null}    [outTangent=null]            -  The outgoing spatial tangent
* @property {boolean}      [_continuous=true]         - true if the specified keyframe has spatial continuity
* @property {boolean}	[_autoBezier=false]			- true if the specified keyframe has temporal auto-Bezier interpolation
* @property {boolean}	[_roving=false]	- true if the specified keyframe is roving
*/
function KeySpatialProperties (){
	this.inTangent = null;
	this.outTangent = null;
	this._continuous = true;
	this._autoBezier = false;
	this._roving = false;
}

/**
* Constructs a new KeyFrame
* @class KeyFrame
* @classdesc Properties of an After Effects Keyframe, as returned by {@linkcode DuAEF.DuAE.Property.getKeyFrames} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtIndex} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtTime}.
* @property {float}	  [_time=0]     - The keyframe time
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}    [value=null]  -  The keyframe value
* @property {KeyframeInterpolationType}   [_inInterpolationType=KeyframeInterpolationType.LINEAR]  - The incoming temporal interpolation type
* @property {KeyframeInterpolationType}	[_outInterpolationType=KeyframeInterpolationType.LINEAR]		- The outgoing temporal interpolation type
* @property {boolean}	[_spatial=false]	- true if this keyframe has a spatial value
* @property {KeySpatialProperties}	[spatialProperties=new KeySpatialProperties()]	- the spatial properties {@linkcode KeySpatialProperties} of this keyframe
* @property {KeyframeEase[]}	[inEase=null]	- The incoming temporal ease. The number of objects in the Array depends on the value type
* @property {KeyframeEase[]}	[outEase=null]	- The outgoing temporal ease. The number of objects in the Array depends on the value type
* @property {boolean}	[_continuous=false]	- true if the keyframe has temporal continuity
* @property {boolean}	[_autoBezier=false]	- true if the keyframe has temporal auto-Bezier interpolation
* @property {int}		[_index=0]	- The index of the keyFrame. Warning: not updated when another key frame is added on the property some time before this key._time!
*/
function KeyFrame(){
	this._time = 0;
	this.value = null;
	this._inInterpolationType = KeyframeInterpolationType.LINEAR;
	this._outInterpolationType = KeyframeInterpolationType.LINEAR;
	this._spatial = false;
	this.spatialProperties = new KeySpatialProperties();
	this.inEase = null;
	this.outEase = null;
	this._continuous = false;
	this._autoBezier = false;
	this._index = 0;
}

/**
* Constructs a new animation
* @class PropertyAnim
* @classdesc Describes the animation of an After Effects property
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {KeyFrame[]}   [keys=[]]  - The keyframes of the animation
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}	[startValue=null]		- The value at the beginning of the animation
* @property {string}   [type="anim"]  - Read Only.
*/
function PropertyAnim(){
	this._name = "";
	this._matchName = "";
	this.keys = [];
	this.startValue = null;
	this.type = "anim";
}

/**
* Constructs a new group animation
* @class PropertyGroupAnim
* @classdesc Contains all PropertyAnim from an After Effects PropertyGroup
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {PropertyAnim[]|PropertyGroupAnim[]}   [anims=[]]  - The animations in the group
* @property {string}   [type="group"]  - Read Only.
*/
function PropertyGroupAnim(){
	this._name = "";
	this._matchName = "";
	this.anims = [];
	this.type = "group";
}

/**
* Constructs a new layer animation
* @class LayerAnim
* @classdesc Contains all PropertyGroupAnim from an After Effects Layer
* @property {string}	  [_name=""]     - The property name
* @property {int}    [_index=""]  - The index of the layer
* @property {PropertyGroupAnim}   transform  - The transform animations
* @property {PropertyGroupAnim}	masks 	- The masks animations
* @property {PropertyGroupAnim}	effects	- The effects animations
* @todo add other propertygroups
*/
function LayerAnim(){
	this._name = "";
	this._index = 0;
	this.transform = new PropertyGroupAnim();
	this.transform._name = "Transform";
	this.transform._matchName = "ADBE Transform Group";
	this.masks = new PropertyGroupAnim();
	this.masks._name = "Masks";
	this.masks._matchName = "ADBE Mask Parade";
	this.effects = new PropertyGroupAnim();
	this.effects._name = "Effects";
	this.effects._matchName = "ADBE Effect Parade";
}

/**
* After Effects tools
* @namespace
* @memberof DuAEF
*/
DuAEF.DuAE = {};

/**
* Converts an After Effects collection to an array.
* @memberof DuAEF.DuAE
* @param {Collection|Array}	collection	- The Collection to convert. If an array is provided, a copy is returned.
* @return {Item[]|Layer[]|OutputModule[]|RenderQueueItem[]}	The values from the collection in an Array
*/
DuAEF.DuAE.convertCollectionToArray = function (collection)
{
	var arr = [];
	if (collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection)
	{
		for (var i = 1;i<=collection.length;i++)
		{
			arr.push(collection[i]);
		}
	}
	else
	{
		arr = collection;
	}
	return arr;
}

/**
* Application related methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.App = {};

//App Properties
(function ()
{
	//detect AE Version
	var reV = /^(\d+\.?\d*)/i;
	var v = app.version.match(reV);

	/**
	* The After Effects version
	* @memberof DuAEF.DuAE.App
	* @type {float}
	*/
	DuAEF.DuAE.App.version = parseFloat(v[1]);

	/**
	 * Has scripting file and network authorization
	 * @type {boolean}
	 */
	DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
})();

/**
* Asks the user to check the file and network security pref if not already set.
* Opens the general prefrences of After Effects.
* @memberof DuAEF.DuAE.App
* @param {boolean}	[showAlert=true]	- Wether to display an alert before opening the preferences
* @param {string}	[message=The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.]	- The message to display in the alert.
* @return {boolean}	Wether the preference has been set
*/
DuAEF.DuAE.App.askFilesAndNetworkAccess = function(showAlert,message)
{
	if (showAlert === undefined) alert = true;
	if (message === undefined ) message = "The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.";
	if (!DuAEF.DuAE.App.hasFilesAndNetworkAccess)
	{

		if (showAlert) alert(message);
		app.executeCommand(2359);

		DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
		return DuAEF.DuAE.App.hasFilesAndNetworkAccess;
	}
}

/**
* Gets the public name of a version of After Effects (like CC2015.3 for version 13.8)
* @param {float}	[versionAsFloat]	- The version as a float. If not provided, will default to the current version of the running instance of After Effects.
* @return {string}	The version name.
*/
DuAEF.DuAE.App.getAEVersionName = function(versionAsFloat)
{
	if (versionAsFloat === undefined) versionAsFloat = DuAEF.DuAE.App.version;
	if (versionAsFloat < 8) return "" + versionAsFloat;
	if (versionAsFloat >= 8 && versionAsFloat < 9) return "CS3";
	if (versionAsFloat >= 9 && versionAsFloat < 10) return "CS4";
	if (versionAsFloat >= 10 && versionAsFloat < 10.5) return "CS5";
	if (versionAsFloat >= 10.5 && versionAsFloat < 11) return "CS5.5";
	if (versionAsFloat >= 11 && versionAsFloat < 12) return "CS6";
	if (versionAsFloat >= 12 && versionAsFloat < 13) return "CC";
	if (versionAsFloat >= 13 && versionAsFloat < 13.1) return "CC2014";
	if (versionAsFloat >= 13.1 && versionAsFloat < 13.2) return "CC2014.1";
	if (versionAsFloat >= 13.2 && versionAsFloat < 13.5) return "CC2014.2";
	if (versionAsFloat >= 13.5 && versionAsFloat < 13.6) return "CC2015";
	if (versionAsFloat >= 13.6 && versionAsFloat < 13.7) return "CC2015.1";
	if (versionAsFloat >= 13.7 && versionAsFloat < 13.8) return "CC2015.2";
	if (versionAsFloat >= 13.8 && versionAsFloat < 14) return "CC2015.3";
	if (versionAsFloat >= 14 && versionAsFloat < 15) return "CC2017";
	if (versionAsFloat >= 15 && versionAsFloat < 16) return "CC2018";
	else return "Unknown";
}

/**
* After Effects project methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Project = {};

/**
* Gets the After Effects current composition
* @return {CompItem|null} The current composition or null if there's no current comp
*/
DuAEF.DuAE.Project.getActiveComp = function()
{
	var comp = app.project.activeItem;
	if (!comp) return null;
	if (!(comp instanceof CompItem)) return null;
	return comp;
}

/**
* After Effects composition methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Comp = {};

/**
* Gets the After Effects selected properties in the current comp
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Comp.getSelectedProps = function(filter,strict,caseSensitive)
{
	var props = [];
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;

	//if no filter, get all using AE native API
	if (filter === undefined)
	{
		return comp.selectedProperties;
	}

	var layers = comp.selectedLayers;
	if (layers.length === 0) return props;

	for (var i = 0 ; i < layers.length ; i++)
	{
		props = props.concat(DuAEF.DuAE.Layer.getSelectedProps(layers[i],filter,strict,caseSensitive));
	}
	return props;
}

/**
* Deselects all properties in the current composition
*/
DuAEF.DuAE.Comp.unselectProperties = function()
{
	var props = DuAEF.DuAE.Comp.getSelectedProps();
	for (var i = 0; i < props.length ; i++)
	{
		props[i].selected = false;
	}
}

/**
* After Effects layer methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Layer = {};

/**
* Gets the After Effects selected properties in the layer
* @param {Layer}	layer	- The layer
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Layer.getSelectedProps = function(layer,filter,strict,caseSensitive)
{
	if (strict === undefined) strict = false;
	if (caseSensitive === undefined) caseSensitive = true;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	var selectedProps = layer.selectedProperties;
	if (filter === undefined)
	{
		props = props.concat(selectedProps);
	}
	else
	{
		for (var j = 0 ; j < selectedProps.length ; j++)
		{
			var prop = selectedProps[j];

			var name = prop.name;
			var matchName = prop.matchName;
			if (!caseSensitive)
			{
				name = name.toLowerCase();
				matchName = matchName.toLowerCase();
			}

			if (strict && name === filter) props.push(prop);
			else if (strict && matchName === filter) props.push(prop);
			else if (typeof filter === "string")
			{
				if (name.indexOf(filter) >= 0) props.push(prop);
				else if (matchName.indexOf(filter) >= 0) props.push(prop);
			}
			else if (prop.propertyType == PropertyType.PROPERTY) if (prop.propertyValueType == filter) props.push(prop);
			else if (prop.propertyType == filter) props.push(prop);
			else if (typeof filter === "function") if (filter(prop)) props.push(prop);
		}
	}

	return props;
}

/**
* Gets all animations on the layer in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Layer}	prop	- The layer.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {LayerAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
* @todo implement!
*/
DuAEF.DuAE.Layer.getAnim = function (layer,selected,timeRange)
{
	var anim = new LayerAnim();
	anim.name = layer.name;
	anim.index = layer.index;
	anim.transform = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Transform Group"));
	anim.masks = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Mask Parade"));
	anim.effects = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Effect Parade"));
}

/**
* After Effects properties methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Property = {};

/**
* Gets the layer containing the property
* @param {Property}	prop	- The After Effects Property
* @return {Layer}	The layer
*/
DuAEF.DuAE.Property.getPropertyLayer = function (prop)
{
	if (prop === undefined) throw "You must provide a property.";
	var parentProp = prop;
	while (parentProp.parentProperty !== null)
	{
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
	}
	return parentProp;
}

/**
* Gets the composition containing the property
* @param {Property}	prop	- The After Effects Property
* @return {CompItem}	The composition
*/
DuAEF.DuAE.Property.getPropertyComp = function (prop)
{
	var layer = DuAEF.DuAE.Property.getPropertyLayer(prop);
	return layer.containingComp;
}

/**
* Gets the key at a given index on a property
* @param {Property}	prop	- The property.
* @param {int}	keyIndex	- The index of the key to retrieve. If the index is negative, it is counted from the end i.e. to retrieve the keyframe before the last one, use -2 (-1 is the last)
* @return {KeyFrame}	The keyframe, or null if incorrect index
*/
DuAEF.DuAE.Property.getKeyFrameAtIndex = function (prop,keyIndex)
{
	if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
	{
		return null;
	}
	if (keyIndex < 0)
	{
		keyIndex = prop.numKeys - keyIndex + 1;
	}

	var key = new KeyFrame();
	key._time = prop.keyTime(keyIndex);
	key.value = prop.keyValue(keyIndex);
	key._inInterpolationType = prop.keyInInterpolationType(keyIndex);
	key._outInterpolationType = prop.keyOutInterpolationType(keyIndex);
	if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
	{
		key._spatial = true;
		key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
		key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
		key.spatialProperties._continuous = prop.keySpatialContinuous(keyIndex);
		key.spatialProperties._autoBezier = prop.keySpatialAutoBezier(keyIndex);
		key.spatialProperties._roving = prop.keyRoving(keyIndex);
	}
	key.inEase = prop.keyInTemporalEase(keyIndex);
	key.outEase = prop.keyOutTemporalEase(keyIndex);
	key._continuous = prop.keyTemporalContinuous(keyIndex);
	key._autoBezier = prop.keyTemporalAutoBezier(keyIndex);
	key._index = keyIndex;

	return key;
}

/**
* Gets the nearest key at a given time on a property
* @param {Property}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time or not found
*/
DuAEF.DuAE.Property.getNearestKeyFrameAtTime = function (prop,time)
{
	return DuAEF.DuAE.Property.getKeyFrameAtIndex(prop.nearestKeyIndex(time));
}

/**
* Gets the key at an exactly given time on a property
* @param {Property}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time
*/
DuAEF.DuAE.Property.getKeyFrameAtTime = function (prop,time)
{
	if (!prop.canVaryOverTime) return null;
	if (prop.numKeys == 0) return null;
	var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.nearestKeyIndex(time));
	if (key === null) return key;
	if (key._time == time) return key;
	else return null;
}

/**
* Gets the property keyframes in the whole timeline or in the time range<br />
* The KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Property}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getKeyFrames = function(prop,selected,timeRange)
{
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

	if (timeRange === undefined) timeRange = [0,23000];
	if (selected === undefined) selected = false;

	var keyFrames = [];

	if (prop.elided) return keyFrames;

	if (prop.isTimeVarying)
	{
		if (selected)
		{
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
		else if (prop.numKeys > 0)
		{
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
	}
	return keyFrames;
}

/**
* Gets the property animation in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Property}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getPropertyAnim = function (prop,selected,timeRange)
{
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

	if (timeRange === undefined) timeRange = [0,23000];

	var anim = new PropertyAnim();
	anim._name = prop.name;
	anim._matchName = prop.matchName;
	anim.startValue = prop.valueAtTime(timeRange[0],true);
	anim.keys = DuAEF.DuAE.Property.getKeyFrames(prop,selected,timeRange);
	return anim;
}

/**
* Gets all animations in the group in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {PropertyGroup}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {PropertyGroupAnim|PropertyAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
*/
DuAEF.DuAE.Property.getPropertyGroupAnim = function (prop,selected,timeRange)
{
	if (prop.propertyType === PropertyType.PROPERTY)
	{
		return DuAEF.DuAE.Property.getPropertyAnim(prop,selected,timeRange);
	}
	else if (prop.numProperties > 0)
	{
		var groupAnim = new PropertyGroupAnim();
		groupAnim._name = prop.name;
		groupAnim._matchName = prop.matchName;

		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var anim = DuAEF.DuAE.Property.getPropertyGroupAnim(prop.property(propIndex),selected,timeRange);
			if (anim !== null) groupAnim.anims.push(anim);
		}

		return groupAnim;
	}
	return null;
}

/**
* Bezier Paths methods
* @namespace
* @memberof DuAEF.DuAE.Property
*/
DuAEF.DuAE.Property.Shape = {};

/**
* Makes a horizontal symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][0];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][0] = center - vertices[i][0];
		inTangents[i][0] = -inTangents[i][0];
		outTangents[i][0] = -outTangents[i][0];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a horizontal symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][0];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][0] = center - vertices[j][0];
			inTangents[j][0] = -inTangents[j][0];
			outTangents[j][0] = -outTangents[j][0];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}

/**
* Makes a vertical symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][1];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][1] = center - vertices[i][1];
		inTangents[i][1] = -inTangents[i][1];
		outTangents[i][1] = -outTangents[i][1];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a vertical symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][1];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][1] = center - vertices[j][1];
			inTangents[j][1] = -inTangents[j][1];
			outTangents[j][1] = -outTangents[j][1];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}
