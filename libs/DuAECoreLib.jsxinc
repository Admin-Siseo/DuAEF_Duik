/*
DuAECoreLib
Library with core After Effects tools. Contains the main class of Duduf AE Framework
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

_Contributors:_
Nicolas Dufresne - Lead developer

This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* Constructs a new KeySpatialProperty
* @class KeySpatialProperties
* @classdesc Spatial properties of a {@linkcode KeyFrame}.
* @property {float[]|null}	  [inTangent=null]     - The incoming spatial tangent
* @property {float[]|null}    [outTangent=null]            -  The outgoing spatial tangent
* @property {boolean}      [_continuous=true]         - true if the specified keyframe has spatial continuity
* @property {boolean}	[_autoBezier=false]			- true if the specified keyframe has temporal auto-Bezier interpolation
* @property {boolean}	[_roving=false]	- true if the specified keyframe is roving
*/
function KeySpatialProperties (){
	this.inTangent = null;
	this.outTangent = null;
	this._continuous = true;
	this._autoBezier = false;
	this._roving = false;
}

/**
* Constructs a new KeyFrame
* @class KeyFrame
* @classdesc Properties of an After Effects Keyframe, as returned by {@linkcode DuAEF.DuAE.Property.getKeyFrames} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtIndex} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtTime}.
* @property {float}	  [_time=0]     - The keyframe time
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}    [value=null]  -  The keyframe value
* @property {KeyframeInterpolationType}   [_inInterpolationType=KeyframeInterpolationType.LINEAR]  - The incoming temporal interpolation type
* @property {KeyframeInterpolationType}	[_outInterpolationType=KeyframeInterpolationType.LINEAR]		- The outgoing temporal interpolation type
* @property {boolean}	[_spatial=false]	- true if this keyframe has a spatial value
* @property {KeySpatialProperties}	[spatialProperties=new KeySpatialProperties()]	- the spatial properties {@linkcode KeySpatialProperties} of this keyframe
* @property {KeyframeEase[]}	[inEase=null]	- The incoming temporal ease. The number of objects in the Array depends on the value type
* @property {KeyframeEase[]}	[outEase=null]	- The outgoing temporal ease. The number of objects in the Array depends on the value type
* @property {boolean}	[_continuous=false]	- true if the keyframe has temporal continuity
* @property {boolean}	[_autoBezier=false]	- true if the keyframe has temporal auto-Bezier interpolation
* @property {int}		[_index=0]	- The index of the keyFrame. Warning: not updated when another key frame is added on the property some time before this key._time!
*/
function KeyFrame(){
	this._time = 0;
	this.value = null;
	this._inInterpolationType = KeyframeInterpolationType.LINEAR;
	this._outInterpolationType = KeyframeInterpolationType.LINEAR;
	this._spatial = false;
	this.spatialProperties = new KeySpatialProperties();
	this.inEase = null;
	this.outEase = null;
	this._continuous = false;
	this._autoBezier = false;
	this._index = 0;
}

/**
* Constructs a new animation
* @class PropertyAnim
* @classdesc Describes the animation of an After Effects property
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {KeyFrame[]}   [keys=[]]  - The keyframes of the animation
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}	[startValue=null]		- The value at the beginning of the animation
* @property {string}	[expression=""]		- The expression on the property, if any.
* @property {string}   [type="anim"]  - Read Only.
*/
function PropertyAnim(){
	this._name = "";
	this._matchName = "";
	this.keys = [];
	this.startValue = null;
	this.type = "anim";
	this.expression = "";
	this.dimensions = 0;
}

/**
* Constructs a new group animation
* @class PropertyGroupAnim
* @classdesc Contains all PropertyAnim from an After Effects PropertyGroup
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {PropertyAnim[]|PropertyGroupAnim[]}   [anims=[]]  - The animations in the group
* @property {string}   [type="group"]  - Read Only.
*/
function PropertyGroupAnim(){
	this._name = "";
	this._matchName = "";
	this.anims = [];
	this.type = "group";
}

/**
* Constructs a new layer animation
* @class LayerAnim
* @classdesc Contains all PropertyGroupAnim from an After Effects Layer
* @property {string}	  [_name=""]     - The property name
* @property {int}    [_index=""]  - The index of the layer
* @property {PropertyGroupAnim}   transform  - The transform animations
* @property {PropertyGroupAnim}	masks 	- The masks animations
* @property {PropertyGroupAnim}	effects	- The effects animations
* @todo add other propertygroups
*/
function LayerAnim(){
	this._name = "";
	this._index = 0;
	this.transform = new PropertyGroupAnim();
	this.transform._name = "Transform";
	this.transform._matchName = "ADBE Transform Group";
	this.masks = new PropertyGroupAnim();
	this.masks._name = "Masks";
	this.masks._matchName = "ADBE Mask Parade";
	this.effects = new PropertyGroupAnim();
	this.effects._name = "Effects";
	this.effects._matchName = "ADBE Effect Parade";
}

/**
* After Effects tools
* @namespace
* @memberof DuAEF
*/
DuAEF.DuAE = {};

/**
* Converts an After Effects collection to an array.
* @memberof DuAEF.DuAE
* @param {Collection|Array}	collection	- The Collection to convert. If an array is provided, a copy is returned.
* @return {Item[]|Layer[]|OutputModule[]|RenderQueueItem[]}	The values from the collection in an Array
*/
DuAEF.DuAE.convertCollectionToArray = function (collection)
{
	var arr = [];
	if (collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection)
	{
		for (var i = 1;i<=collection.length;i++)
		{
			arr.push(collection[i]);
		}
	}
	else
	{
		arr = collection;
	}
	return arr;
}

/**
* Application related methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.App = {};

//App Properties
(function ()
{
	//detect AE Version
	var reV = /^(\d+\.?\d*)/i;
	var v = app.version.match(reV);

	/**
	* The After Effects version
	* @memberof DuAEF.DuAE.App
	* @type {float}
	*/
	DuAEF.DuAE.App.version = parseFloat(v[1]);

	/**
	 * Has scripting file and network authorization
	 * @type {boolean}
	 */
	DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
})();

/**
* Asks the user to check the file and network security pref if not already set.
* Opens the general prefrences of After Effects.
* @memberof DuAEF.DuAE.App
* @param {boolean}	[showAlert=true]	- Wether to display an alert before opening the preferences
* @param {string}	[message=The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.]	- The message to display in the alert.
* @return {boolean}	Wether the preference has been set
*/
DuAEF.DuAE.App.askFilesAndNetworkAccess = function(showAlert,message)
{
	if (showAlert == undefined) alert = true;
	if (message == undefined ) message = "The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.";
	if (!DuAEF.DuAE.App.hasFilesAndNetworkAccess)
	{

		if (showAlert) alert(message);
		app.executeCommand(2359);

		DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
		return DuAEF.DuAE.App.hasFilesAndNetworkAccess;
	}
}

/**
* Gets the public name of a version of After Effects (like CC2015.3 for version 13.8)
* @param {float}	[versionAsFloat]	- The version as a float. If not provided, will default to the current version of the running instance of After Effects.
* @return {string}	The version name.
*/
DuAEF.DuAE.App.getAEVersionName = function(versionAsFloat)
{
	if (versionAsFloat == undefined) versionAsFloat = DuAEF.DuAE.App.version;
	if (versionAsFloat < 8) return "" + versionAsFloat;
	if (versionAsFloat >= 8 && versionAsFloat < 9) return "CS3";
	if (versionAsFloat >= 9 && versionAsFloat < 10) return "CS4";
	if (versionAsFloat >= 10 && versionAsFloat < 10.5) return "CS5";
	if (versionAsFloat >= 10.5 && versionAsFloat < 11) return "CS5.5";
	if (versionAsFloat >= 11 && versionAsFloat < 12) return "CS6";
	if (versionAsFloat >= 12 && versionAsFloat < 13) return "CC";
	if (versionAsFloat >= 13 && versionAsFloat < 13.1) return "CC2014";
	if (versionAsFloat >= 13.1 && versionAsFloat < 13.2) return "CC2014.1";
	if (versionAsFloat >= 13.2 && versionAsFloat < 13.5) return "CC2014.2";
	if (versionAsFloat >= 13.5 && versionAsFloat < 13.6) return "CC2015";
	if (versionAsFloat >= 13.6 && versionAsFloat < 13.7) return "CC2015.1";
	if (versionAsFloat >= 13.7 && versionAsFloat < 13.8) return "CC2015.2";
	if (versionAsFloat >= 13.8 && versionAsFloat < 14) return "CC2015.3";
	if (versionAsFloat >= 14 && versionAsFloat < 15) return "CC2017";
	if (versionAsFloat >= 15 && versionAsFloat < 16) return "CC2018";
	else return "Unknown";
}

/**
* After Effects project methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Project = {};

/**
* Gets the After Effects current composition
* @return {CompItem|null} The current composition or null if there's no current comp
*/
DuAEF.DuAE.Project.getActiveComp = function()
{
	var comp = app.project.activeItem;
	if (!comp) return null;
	if (!(comp instanceof CompItem)) return null;
	return comp;
}

/**
* After Effects composition methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Comp = {};

/**
* Gets the After Effects selected properties in the current comp
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Comp.getSelectedProps = function(filter,strict,caseSensitive)
{
	var props = [];
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;

	//if no filter, get all using AE native API
	if (filter == undefined)
	{
		return comp.selectedProperties;
	}

	var layers = comp.selectedLayers;
	if (layers.length === 0) return props;

	for (var i = 0 ; i < layers.length ; i++)
	{
		props = props.concat(DuAEF.DuAE.Layer.getSelectedProps(layers[i],filter,strict,caseSensitive));
	}
	return props;
}

/**
* Deselects all properties in the current composition
*/
DuAEF.DuAE.Comp.unselectProperties = function()
{
	var props = DuAEF.DuAE.Comp.getSelectedProps();
	for (var i = 0; i < props.length ; i++)
	{
		props[i].selected = false;
	}
}

/**
* Deselects all layers in the current composition
* @return {Layer[]} The previously selected layers
*/
DuAEF.DuAE.Comp.unselectLayers = function()
{
	var comp = app.project.activeItem;

	var layers = [];

	if (!comp) return layers;
	if (!(comp instanceof CompItem)) return layers;

	layers = comp.selectedLayers;

	while (comp.selectedLayers.length > 0)
	{
		comp.selectedLayers[0].selected = false;
	}

	return layers;
}

/**
* Selects the layers
* @param {Layer[]} layers - The layers
*/
DuAEF.DuAE.Comp.selectLayers = function (layers)
{
	for (var i = 0 ; i < layers.length ; i++)
	{
		layers[i].selected = true;
	}
}

/**
* Generates a new unique name for a layer
* @param {string} newName	- The wanted new name
* @param {CompItem} comp 	- The comp
* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Comp.newUniqueLayerName = function(newName, comp)
{
	var layerNames = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		layerNames.push(comp.layer(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,layerNames);
}

/**
* After Effects layer methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Layer = {};

/**
* Generates a new unique name for an effect
* @param {string} newName	- The wanted new name
* @param {Layer} layer 	- The layer
* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Layer.newUniqueEffectName = function(newName, layer)
{
	if (!layer) throw "Needs a layer to generate a new unique effect name";
	var effectNames = [];
	for (var i = 1 ; i <= layer.effect.numProperties ; i++)
	{
		effectNames.push(layer.effect(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,effectNames);
}

/**
* Gets the After Effects selected properties in the layer
* @param {Layer}	layer	- The layer
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Layer.getSelectedProps = function(layer,filter,strict,caseSensitive)
{
	if (strict == undefined) strict = false;
	if (caseSensitive == undefined) caseSensitive = true;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	var selectedProps = layer.selectedProperties;
	if (filter == undefined)
	{
		props = props.concat(selectedProps);
	}
	else
	{
		for (var j = 0 ; j < selectedProps.length ; j++)
		{
			var prop = selectedProps[j];

			var name = prop.name;
			var matchName = prop.matchName;
			if (!caseSensitive)
			{
				name = name.toLowerCase();
				matchName = matchName.toLowerCase();
			}

			if (strict && name === filter) props.push(prop);
			else if (strict && matchName === filter) props.push(prop);
			else if (typeof filter === "string")
			{
				if (name.indexOf(filter) >= 0) props.push(prop);
				else if (matchName.indexOf(filter) >= 0) props.push(prop);
			}
			else if (prop.propertyType == PropertyType.PROPERTY) if (prop.propertyValueType == filter) props.push(prop);
			else if (prop.propertyType == filter) props.push(prop);
			else if (typeof filter === "function") if (filter(prop)) props.push(prop);
		}
	}

	return props;
}

/**
* Gets all animations on the layer in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Layer}	layer	- The layer.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {LayerAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
* @todo implement!
*/
DuAEF.DuAE.Layer.getAnim = function (layer,selected,timeRange)
{
	var anim = new LayerAnim();
	anim._name = layer.name;
	anim._index = layer.index;
	anim.transform = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Transform Group"),selected,timeRange);
	anim.masks = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Mask Parade"),selected,timeRange);
	anim.effects = DuAEF.DuAE.Property.getPropertyGroupAnim(layer.property("ADBE Effect Parade"),selected,timeRange);
	return anim;
}

/**
* Sets the property animation on the property
* @param {Layer}	layer	- The layer.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Set the expression on the property
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Layer.setAnim = function(layer,anim,time,ignoreName,setExpression)
{
	if (time == undefined) time = layer.containingComp.time;
	if (ignoreName == undefined) ignoreName = false;
	if (setExpression == undefined) setExpression = false;

	var matchName = anim._matchName;
	var name = anim._name;

	var ok = false;

	DuAEF.DuAE.Property.setGroupAnim(layer.property("ADBE Transform Group"),anim.transform,time,true,setExpression);
	DuAEF.DuAE.Property.setGroupAnim(layer.property("ADBE Mask Parade"),anim.masks,time,ignoreName,setExpression);
	DuAEF.DuAE.Property.setGroupAnim(layer.property("ADBE Effect Parade"),anim.effects,time,ignoreName,setExpression);
}

/**
* Gets the children of a layer
* @param {Layer}	layer	- The layer.
* @return {Layer[]} All the children of the layer
*/
DuAEF.DuAE.Layer.getChildren = function(layer)
{
	var comp = layer.containingComp;
	var children = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		var l = comp.layer(i);
		if (l.index == layer.index) continue;
		if (l.parent == null) continue;
		if (l.parent.index == layer.index) children.push(l);
	}
	return children;
}

/**
* After Effects properties methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Property = {};

/**
* Gets the layer containing the property
* @param {Property}	prop	- The After Effects Property
* @return {Layer}	The layer
*/
DuAEF.DuAE.Property.getLayer = function (prop)
{
	if (prop == undefined) throw "You must provide a property.";
	var parentProp = prop;
	while (parentProp.parentProperty !== null)
	{
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
	}
	return parentProp;
}

/**
* Gets the composition containing the property
* @param {Property}	prop	- The After Effects Property
* @return {CompItem}	The composition
*/
DuAEF.DuAE.Property.getComp = function (prop)
{
	var layer = DuAEF.DuAE.Property.getPropertyLayer(prop);
	return layer.containingComp;
}

/**
* Gets the number of dimensions of a property
* @param {Property}	prop	- The After Effects Property
* @return {int}	The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
*/
DuAEF.DuAE.Property.getDimensions = function (prop)
{
	var dimensions = 0;
	if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
	{
		//if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
		if ((prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position") && !DuAEF.DuAE.Property.getLayer(prop).threeDLayer)
		{
			dimensions = 2;
		}
		else
		{
			dimensions = 3;
		}
	}
	else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
	{
		dimensions = 2;
	}
	else if (prop.propertyValueType == PropertyValueType.OneD)
	{
		dimensions = 1;
	}
	return dimensions;
}

/**
* Gets the key at a given index on a property
* @param {Property}	prop	- The property.
* @param {int}	keyIndex	- The index of the key to retrieve. If the index is negative, it is counted from the end i.e. to retrieve the keyframe before the last one, use -2 (-1 is the last)
* @return {KeyFrame}	The keyframe, or null if incorrect index
*/
DuAEF.DuAE.Property.getKeyFrameAtIndex = function (prop,keyIndex)
{
	if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
	{
		return null;
	}
	if (keyIndex < 0)
	{
		keyIndex = prop.numKeys - keyIndex + 1;
	}

	var key = new KeyFrame();
	key._time = prop.keyTime(keyIndex);
	key.value = prop.keyValue(keyIndex);
	key._inInterpolationType = prop.keyInInterpolationType(keyIndex);
	key._outInterpolationType = prop.keyOutInterpolationType(keyIndex);
	if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
	{
		key._spatial = true;
		key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
		key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
		key.spatialProperties._continuous = prop.keySpatialContinuous(keyIndex);
		key.spatialProperties._autoBezier = prop.keySpatialAutoBezier(keyIndex);
		key.spatialProperties._roving = prop.keyRoving(keyIndex);
	}
	key.inEase = prop.keyInTemporalEase(keyIndex);
	key.outEase = prop.keyOutTemporalEase(keyIndex);
	key._continuous = prop.keyTemporalContinuous(keyIndex);
	key._autoBezier = prop.keyTemporalAutoBezier(keyIndex);
	key._index = keyIndex;

	return key;
}

/**
* Gets the nearest key at a given time on a property
* @param {Property}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time or not found
*/
DuAEF.DuAE.Property.getNearestKeyFrameAtTime = function (prop,time)
{
	return DuAEF.DuAE.Property.getKeyFrameAtIndex(prop.nearestKeyIndex(time));
}

/**
* Gets the key at an exactly given time on a property
* @param {Property}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time
*/
DuAEF.DuAE.Property.getKeyFrameAtTime = function (prop,time)
{
	if (!prop.canVaryOverTime) return null;
	if (prop.numKeys == 0) return null;
	var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.nearestKeyIndex(time));
	if (key === null) return key;
	if (key._time == time) return key;
	else return null;
}

/**
* Gets the property keyframes in the whole timeline or in the time range<br />
* The KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Property}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getKeyFrames = function(prop,selected,timeRange)
{
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

	if (timeRange == undefined) timeRange = [0,23000];
	if (selected == undefined) selected = false;

	var keyFrames = [];

	if (prop.elided) return keyFrames;

	if (prop.isTimeVarying)
	{
		if (selected)
		{
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
		else if (prop.numKeys > 0)
		{
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
	}
	return keyFrames;
}

/**
* Gets the property animation in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Property}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getAnim = function (prop,selected,timeRange)
{
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

	if (timeRange == undefined) timeRange = [0,23000];

	var anim = new PropertyAnim();
	anim._name = prop.name;
	anim._matchName = prop.matchName;
	anim.startValue = prop.valueAtTime(timeRange[0],true);
	anim.keys = DuAEF.DuAE.Property.getKeyFrames(prop,selected,timeRange);
	anim.dimensions = DuAEF.DuAE.Property.getDimensions(prop);
	if (prop.canSetExpression) anim.expression = prop.expression;
	return anim;
}

/**
* Gets all animations in the group in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {PropertyGroup}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange=[0,23000]]	- The time range, an array of two time values, in seconds.
* @return {PropertyGroupAnim|PropertyAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
*/
DuAEF.DuAE.Property.getGroupAnim = function (prop,selected,timeRange)
{
	if (prop.propertyType === PropertyType.PROPERTY)
	{
		return DuAEF.DuAE.Property.getPropertyAnim(prop,selected,timeRange);
	}
	else if (prop.numProperties > 0)
	{
		var groupAnim = new PropertyGroupAnim();
		groupAnim._name = prop.name;
		groupAnim._matchName = prop.matchName;

		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var anim = DuAEF.DuAE.Property.getPropertyGroupAnim(prop.property(propIndex),selected,timeRange);
			if (anim !== null) groupAnim.anims.push(anim);
		}

		return groupAnim;
	}
	return null;
}

/**
* Sets a {@linkcode KeyFrame} on a property
* @param {Property}	prop	- The property.
* @param {KeyFrame}	key	- The KeyFrame.
* @param {float}	[timeOffset=comp.time]	- The time offset (added to KeyFrame._time) where to add the key frame.
*/
DuAEF.DuAE.Property.setKey = function (prop,key,timeOffset)
{
	if (prop.elided) return;
	if (!prop.propertyType === PropertyType.PROPERTY) throw "Can not set a key on a group property";
	if (!prop.canVaryOverTime) return;

	if (timeOffset == undefined) timeOffset = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	var time = key._time + timeOffset;
	var propDimensions = DuAEF.DuAE.Property.getDimensions(prop);
	var val = key.value;

	if (propDimensions > 1 && !(val instanceof Array))
	{
		val = [val];
	}

	//adjust dimensions
	if (val instanceof Array)
	{
		while (val.length < propDimensions)
		{
			val.push(0);
		}
		while (val.length > propDimensions)
		{
			val.pop();
		}

		//if spatial, do the same for spatial tangents
		if (prop.isSpatial)
		{
			while (key.spatialProperties.inTangent.length < propDimensions)
			{
				key.spatialProperties.inTangent.push(0);
			}
			while (key.spatialProperties.inTangent.length > propDimensions)
			{
				key.spatialProperties.inTangent.pop();
			}

			while (key.spatialProperties.outTangent.length < propDimensions)
			{
				key.spatialProperties.outTangent.push(0);
			}
			while (key.spatialProperties.outTangent.length > propDimensions)
			{
				key.spatialProperties.outTangent.pop();
			}
		}
	}

	try
	{
		prop.setValueAtTime(time,val);

		//get the index of the created key
		var index = prop.nearestKeyIndex(time);

		//set interpolations
		if (key._spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
		{
			try{
				prop.setSpatialContinuousAtKey(index,key.spatialProperties._continuous);
				prop.setSpatialAutoBezierAtKey(index,key.spatialProperties._autoBezier);
				prop.setRovingAtKey(index,key.spatialProperties._roving);
				prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
			}
			catch(err)
			{
				alert(err.description);
			};
		}

		try
		{
			prop.setTemporalContinuousAtKey(index,key._continuous);
			prop.setTemporalAutoBezierAtKey(index,key._autoBezier);
			prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
			prop.setInterpolationTypeAtKey(index,key._inInterpolationType,key._outInterpolationType);
		}
		catch(err)
		{
			alert(err.description);
		}

	}
	catch (err)
	{}
}

/**
* Sets the property animation on the property
* @param {Property}	prop	- The property.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Sets the expression too
* @param {boolean}	[ignoreMatchName=false]	- true to set the anim even if matchName of the property do not match the animation.
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setAnim = function(prop,anim,time,ignoreName,setExpression,ignoreMatchName)
{
	if (time == undefined) time = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	if (ignoreName == undefined) ignoreName = false;
	if (ignoreMatchName == undefined) ignoreMatchName = false;
	if (setExpression == undefined) setExpression = false;

	var matchName = anim._matchName;
	var name = anim._name;
	var dimensions = anim.dimensions;

	var ok = false;

	if (anim == null) return true;

	//find the property with the same name and matchname
	if (prop.propertyType === PropertyType.PROPERTY && !prop.elided && prop.canVaryOverTime && DuAEF.DuAE.Property.getDimensions(prop) == dimensions)
	{
		if ((!ignoreMatchName && prop.matchName == matchName || ignoreMatchName) && (!ignoreName && prop.name == name || ignoreName))
		{
			//if there are keys, set them
			if (anim.keys.length > 0)
			{
				for (var iclef = 0; iclef < anim.keys.length;iclef++)
				{
					DuAEF.DuAE.Property.setKey(prop,anim.keys[iclef],time);
					ok = true;
				}
			}
			else //set the start value
			{
				try
				{
					var value = anim.startValue;
					if (value instanceof Array)
					{
						while (value.length < dimensions)
						{
							value.push(0);
						}
						while (value.length > dimensions)
						{
							value.pop();
						}
					}
					if (anim.startValue != null) prop.setValue(anim.startValue);
					ok = true;
				} catch (err) {};
			}
			//set the expression
			if (prop.canSetExpression && setExpression)
			{
				prop.expression = anim.expression;
			}
		}
	}
	else if (prop.numProperties != undefined)
	{
		if (prop.numProperties > 0)
		{
			for (var pi = 1;pi <= prop.numProperties;pi++)
			{
				ok = (DuAEF.DuAE.Property.setAnim(prop.property(pi),anim,time,ignorName,setExpression));
			}
		}
	}
	return ok;
}

/**
* Sets all animations from a property group
* @param {PropertyGroup}	prop	- The property group.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Sets the expression too
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setGroupAnim = function(prop,anim,time,ignoreName,setExpression)
{
	if (time == undefined) time = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	if (ignoreName == undefined) ignoreName = false;
	if (setExpression == undefined) setExpression = false;

	var ok = false;

	if (anim == null) return true;

	if (prop.matchName == anim._matchName && (!ignoreName && prop.name == anim._name || ignoreName))
	{
		for (var i = 0 ; i < anim.anims.length ; i++)
		{
			var propAnim = anim.anims[i];
			//find the property with the same name and matchname
			for (var j = 1 ; j <= prop.numProperties ; j++)
			{
				var subProp = prop.property(j);
				if (subProp.matchName == propAnim._matchName && (!ignoreName && subProp.name == propAnim._name || ignoreName))
				{
					if (propAnim.type == "group") ok = DuAEF.DuAE.Property.setGroupAnim(subProp,propAnim,time,ignoreName,setExpression);
					else ok = DuAEF.DuAE.Property.setAnim(subProp,propAnim,time,ignoreName,setExpression);
					break;
				}
			}
		}
	}
	return ok;
}

/**
* Removes the animation from the property
* @param {Property} prop -The property
* @param {boolean} [removeExpression=false] - Set to true to remove the expression too
*/
DuAEF.DuAE.Property.removeAnim = function(prop,removeExpression)
{
	while (prop.numKeys > 0)
	{
		prop.removeKey(1);
	}
	if (removeExpression && prop.canSetExpression)
	{
		prop.expression = '';
	}
}

/**
* Bezier Paths methods
* @namespace
* @memberof DuAEF.DuAE.Property
*/
DuAEF.DuAE.Property.Shape = {};

/**
* Makes a horizontal symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][0];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][0] = center - vertices[i][0];
		inTangents[i][0] = -inTangents[i][0];
		outTangents[i][0] = -outTangents[i][0];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a horizontal symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][0];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][0] = center - vertices[j][0];
			inTangents[j][0] = -inTangents[j][0];
			outTangents[j][0] = -outTangents[j][0];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}

/**
* Makes a vertical symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][1];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][1] = center - vertices[i][1];
		inTangents[i][1] = -inTangents[i][1];
		outTangents[i][1] = -outTangents[i][1];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a vertical symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][1];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][1] = center - vertices[j][1];
			inTangents[j][1] = -inTangents[j][1];
			outTangents[j][1] = -outTangents[j][1];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}
