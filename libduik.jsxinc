/*Duik - Duduf IK ToolsCopyright (c) 2008 - 2015 Nicolas Dufresnehttp://www.duduf.netMany thanks to :Dan Ebberts - Writing the first IK ExpressionsEric Epstein - making the IK's work with 3D LayersAll 258 indiegogo crowdfunders for making this libDuik possible!This file is part of Duik.    Duik is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    Duik is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with Duik. If not, see <http://www.gnu.org/licenses/>.*/// =====================================================================//                                   LibDuik // =====================================================================/* This file should not be edited,	If you need to change some settings, you should change them inside your own script.	Example:	Changing controllers size (in pixels):		Duik.settings.controllerSize = 50;			A complete list of settings is available in the developper's guide of libDuik on	http://www.duduf.net		If you need to change UI strings (for localization) you can access them in Duik.uiStrings	Example:		Duik.uiStrings.ikFkBox = "IK / FK"			A complete list of uiStrings is available in the developper's guide of libDuik on	http://www.duduf.net		However, if you're modifying this file, you may want to force reload the class for testing purposes.	Uncomment the first line of the script (FORCE RELOAD section)		if (typeof Duik === 'object') delete Duik;	*//////////////////////////////// FORCE RELOAD/////////////////////////////if (typeof Duik === 'object') delete Duik;////////////////////////////// DEFINITIONS////////////////////////////if (typeof Duik !== 'object'){    Duik = {};	Duik.versionNumber = 0.0;}function KeySpatialProperties (){	this.inTangent = null;	this.outTangent = null;	this.continuous = true;	this.autoBezier = false;	this.roving = false;}function KeyFrame(){	this.time = 0;	this.value = null;	this.inInterpolationType = KeyframeInterpolationType.LINEAR;	this.outInterpolationType = KeyframeInterpolationType.LINEAR;	this.spatial = false;	this.spatialProperties = new KeySpatialProperties();	this.inEase = 0;	this.outEase = 0;	this.continuous = false;	this.autoBezier = false;}function PropertyAnim(){	this.name = "";	this.keys = [];	this.startValue = null;}function MaskAnim(){	this.name = "";	this.anims = [];}function EffectAnim(){	this.name = "";	this.matchName = "";	this.anims = [];}function LayerAnim(){	this.name = "";	this.index = 0;	this.transformAnims = [];	this.masksAnims = [];	this.effectsAnims = [];}/////////////////////////////// INITIALIZATION/////////////////////////////(function (){	if (Duik.versionNumber != 15.0008)	{		delete Duik;		Duik = {};		Duik.version = "15.alpha8";		Duik.versionNumber = 15.0008;		Duik.usePresets = true;		Duik.presetPath = $.fileName.substring(0,$.fileName.lastIndexOf("/")) + "/";		Duik.presetEffectsInstalledVersion = 0.0;		Duik.copiedAnim = [];	}}());/////////////////////////////// INSTALLATION CHECKS/////////////////////////////(function (){	//=======================	//===== METHODS =========	//=======================	if (typeof Duik.setup !== 'object')	{		Duik.setup = {};		//Duik.setup.presetEffects String		{			Duik.setup.presetEffects = "<!-- BEGIN DUIK PSEUDO EFFECTS v15.0008 -->\r\n" + 				"<Effect matchname='DUIK_One_Layer_IK' name='$$$/AE/Preset/1ik=DUIK_One_Layer_IK'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 				"    <Checkbox name='$$$/AE/Preset/Reverse=Reverse' default='true'/>\r\n" + 				"    <Angle name='$$$/AE/Preset/FK=FK' default='0'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Two_Layer_IK' name='$$$/AE/Preset/2ik=DUIK_Two_Layer_IK'>\r\n" + 				"    <Checkbox name='$$$/AE/Preset/Clockwise=Clockwise' default='false'/>\r\n" + 				"    <Group name='$$$/AE/Preset/FK=FK'>\r\n" + 				"        <Checkbox name='$$$/AE/Preset/DisableIK=Disable IK' default='false'/>\r\n" + 				"        <Angle name='$$$/AE/Preset/UpperFK=Upper FK' default='0'/>\r\n" + 				"        <Angle name='$$$/AE/Preset/LowerFK=Lower FK' default='0'/>\r\n" + 				"    </Group>\r\n" + 				"    <Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" + 				"        <Checkbox name='$$$/AE/Preset/Auto-Stretch=Auto-Stretch' default='true'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/Stretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_3D_Wiggle' name='$$$/AE/Preset/3dwiggle=DUIK_3D_Wiggle'>\r\n" + 				"    <Group name='$$$/AE/Preset/Amplitudes=Amplitudes'>\r\n" + 				"        <Slider name='$$$/AE/Preset/XAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/YAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/ZAmp=Z Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"    <Group name='$$$/AE/Preset/Frequencies=Frequencies'>\r\n" + 				"        <Slider name='$$$/AE/Preset/XFrequ=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/YFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/ZFreq=Z Freq' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_2D_Wiggle' name='$$$/AE/Preset/2dwiggle=DUIK_2D_Wiggle'>\r\n" + 				"    <Group name='$$$/AE/Preset/Amplitudes=Amplitudes'>\r\n" + 				"        <Slider name='$$$/AE/Preset/XAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/YAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"    <Group name='$$$/AE/Preset/Frequencies=Frequencies'>\r\n" + 				"        <Slider name='$$$/AE/Preset/XFreq=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/YFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_1D_Wiggle' name='$$$/AE/Preset/1dwiggle=DUIK_1D_Wiggle'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Amplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Frequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Exposure' name='$$$/AE/Preset/exposure=DUIK_Exposure'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Exposure=Exposure (frames)' default='1' valid_min='1' valid_max='1000' slider_min='1' slider_max='30' precision='1'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_RotMorph' name='$$$/AE/Preset/rotmorph=DUIK_RotMorph'>\r\n" + 				"    <Layer name='$$$/AE/Preset/ReferenceLayer=Reference Layer' default_self='true'/>\r\n" + 				"    <Angle name='$$$/AE/Preset/Min.Angle=Min. Angle' default='0'/>\r\n" + 				"    <Angle name='$$$/AE/Preset/Max.Angle=Max. Angle' default='0'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Swing' name='$$$/AE/Preset/swing=DUIK_Swing'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Amplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Frequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='50' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Damping=Damping' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Wheel' name='$$$/AE/Preset/wheel=DUIK_Wheel'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Radius=Radius' default='100' valid_min='1' valid_max='10000' slider_min='1' slider_max='1000' precision='1'/>\r\n" + 				"    <Checkbox name='$$$/AE/Preset/Reverse=Reverse' default='false'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_LensFlare' name='$$$/AE/Preset/lensflare=DUIK_LensFlare'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Intensity=Intensity' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Scale=Scale' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_LensFlareDistance' name='$$$/AE/Preset/lensflaredistance=DUIK_LensFlareDistance'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Distance=Distance' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_DistanceLink' name='$$$/AE/Preset/distancelink=DUIK_DistanceLink'>\r\n" + 				"    <Group name='$$$/AE/Preset/Range=Range'>\r\n" + 				"        <Slider name='$$$/AE/Preset/MinimumDistance=Minimum Distance' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"        <Slider name='$$$/AE/Preset/MaximumDistance=Maximum Distance' default='500' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 				"    </Group>\r\n" + 				"    <Checkbox name='$$$/AE/Preset/Reverse=Reverse' default='false'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Falloff=Falloff' default='10' valid_min='0' valid_max='1000' slider_min='0' slider_max='100' precision='1'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Spring' name='$$$/AE/Preset/spring=DUIK_Spring'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Elasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Damping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" + 				"</Effect>\r\n" + 				"<Effect matchname='DUIK_Spring_Bounce' name='$$$/AE/Preset/springbounce=DUIK_Spring_Bounce'>\r\n" + 				"    <Slider name='$$$/AE/Preset/Elasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" + 				"    <Slider name='$$$/AE/Preset/Damping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" + 				"    <Checkbox name='$$$/AE/Preset/Bounce=Bounce' default='false'/>\r\n" + 				"</Effect>\r\n" + 				"<!-- END DUIK PSEUDO EFFECTS -->\r\n";		}		// INSTALL PSEUDO EFFECTS - Duik.setup.installCustomEffects();		Duik.setup.installPseudoEffects = function ()		{			//-------------------------------------------------------------			//------ Edit presetEffects.xml to add Duik Effects -----------			//-------------------------------------------------------------			if (Duik.allowedToWriteFiles && Duik.presetEffectsInstalledVersion < Duik.versionNumber)			{				var presetEffectsFile = new File(Folder.startup.fullName + "/PresetEffects.xml");				if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(Folder.startup.parent.fullName + "/Resources/PresetEffects.xml");				if (presetEffectsFile.exists)				{					presetEffectsFile.open("r");					var presetEffectsString = presetEffectsFile.read();					presetEffectsFile.close();					//update					var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");					var endIndex = presetEffectsString.indexOf("<!-- END DUIK PSEUDO EFFECTS -->") + 32;					if (startIndex >= 0)					{						var stringToRemove = presetEffectsString.substring(startIndex,endIndex);						presetEffectsString = presetEffectsString.replace(stringToRemove,Duik.setup.presetEffects);					}					else					{						presetEffectsString = presetEffectsString.replace("</Effects>",Duik.setup.presetEffects + "\r\n</Effects>");					}					//backup file					presetEffectsFile.copy(presetEffectsFile.fullName + ".bak");					//write the new file					var isReadOnly = presetEffectsFile.readonly;					presetEffectsFile.readonly = false;					presetEffectsFile.open("w");					presetEffectsFile.write(presetEffectsString);					presetEffectsFile.close();					presetEffectsFile.readonly = isReadOnly;				}				Duik.setup.checkPresetEffectsVersion();			}		}		Duik.setup.checkPresetEffectsVersion = function ()		{			var presetEffectsFile = new File(Folder.startup.fullName + "/PresetEffects.xml");			if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(Folder.startup.parent.fullName + "/Resources/PresetEffects.xml");			Duik.presetEffectsInstalledVersion = 0;			if (presetEffectsFile.exists)			{				presetEffectsFile.open("r");				var presetEffectsString = presetEffectsFile.read();				presetEffectsFile.close();				//find version				var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");				if (startIndex >= 0)				{					startIndex += 32 ;					Duik.presetEffectsInstalledVersion = parseFloat(presetEffectsString.substr(startIndex,7));				}			}		}			//-----------------------------------------------------------------		//--------- Check if presetEffects.xml is up-to-date --------------		//-----------------------------------------------------------------		Duik.setup.checkPresetEffectsVersion();		if (Duik.presetEffectsInstalledVersion == Duik.versionNumber)		{			Duik.usePresets = false;		}	}		//-----------------------------------------------------------------	//--------- Check if scripts are allowed to write files -----------	//-----------------------------------------------------------------	Duik.allowedToWriteFiles = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;		//-----------------------------------------------------------------	//------------------------------ INSTALL --------------------------	//-----------------------------------------------------------------	if (Duik.usePresets)	{		Duik.setup.installPseudoEffects();	}}());/////////////////////////////// MAIN/////////////////////////////(function (){		//================================	//========= UI Strings ===========	//================================		/* UI Strings		Localisation				TODO		class Duik.uiStrings		containing all needed uiString (localizable strings)				Duik.setLanguage(lang)		lang | string, language code	*/	if (typeof Duik.uiStrings !== 'object')	{		Duik.uiStrings = {};				Duik.uiStrings.ik = "IK";		Duik.uiStrings.wiggle = "Wiggle";		Duik.uiStrings.exposure = "Exposure";		Duik.uiStrings.rotMorph = "Rotation Morph";		Duik.uiStrings.swing = "Swing";		Duik.uiStrings.wheel = "Wheel";		Duik.uiStrings.lensFlare = "Lens Flare";		Duik.uiStrings.distanceLink = "Distance Link";		Duik.uiStrings.spring = "Spring";	}	//================================	//========= SETTINGS =============	//================================		/* Duik Settings		*/	if (typeof Duik.settings !== 'object')	{		Duik.settings = {};				Duik.sizes = {};		Duik.sizes.SMALL = 0;		Duik.sizes.MEDIUM = 1;		Duik.sizes.BIG = 2;				Duik.layerTypes = {};		Duik.layerTypes.NULL = 1;		Duik.layerTypes.SOLID = 0;						if (! app.settings.haveSetting("duik", "boneType")){app.settings.saveSetting("duik","boneType",Duik.layerTypes.SOLID);}		if (! app.settings.haveSetting("duik", "boneSize")){app.settings.saveSetting("duik","boneSize",20);}		if (! app.settings.haveSetting("duik", "ctrlSize")){app.settings.saveSetting("duik","ctrlSize",100);}		if (! app.settings.haveSetting("duik", "ctrlSizeAuto")){app.settings.saveSetting("duik","ctrlSizeAuto",true);}		if (! app.settings.haveSetting("duik", "boneSizeAuto")){app.settings.saveSetting("duik","boneSizeAuto",true);}		if (! app.settings.haveSetting("duik", "boneSizeAutoValue")){app.settings.saveSetting("duik","boneSizeAutoValue",Duik.sizes.MEDIUM);}		if (! app.settings.haveSetting("duik", "ctrlSizeAutoValue")){app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.sizes.MEDIUM);}		if (! app.settings.haveSetting("duik", "boneColor")){app.settings.saveSetting("duik","boneColor","FF0000");}		if (! app.settings.haveSetting("duik", "morpherKeyframes")){app.settings.saveSetting("duik","morpherKeyframes",true);}		if (! app.settings.haveSetting("duik", "pasteAnimUseIndexes")){app.settings.saveSetting("duik","pasteAnimUseIndexes",false);}				Duik.settings.save = function ()		{			app.settings.saveSetting("duik","boneType",Duik.settings.boneType);			app.settings.saveSetting("duik","boneSize",Duik.settings.boneSize);			app.settings.saveSetting("duik","ctrlSize",Duik.settings.controllerSize);			app.settings.saveSetting("duik","ctrlSizeAuto",Duik.settings.controllerSizeAuto);			app.settings.saveSetting("duik","boneSizeAuto",Duik.settings.boneSizeAuto);			app.settings.saveSetting("duik","boneSizeAutoValue",Duik.settings.boneSizeHint);			app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.settings.controllerSizeHint);			app.settings.saveSetting("duik","boneColor",Duik.settings.boneColor);			app.settings.saveSetting("duik","morpherKey",Duik.settings.morpherCreatesKeyframes);			app.settings.saveSetting("duik","pasteAnimUseIndexes",Duik.settings.pasteAnimUseIndexes);		}				Duik.settings.load = function ()		{			Duik.settings.controllerSize = eval(app.settings.getSetting("duik","ctrlSize"));			Duik.settings.controllerSizeAuto = eval(app.settings.getSetting("duik","ctrlSizeAuto"));			Duik.settings.controllerSizeHint = eval(app.settings.getSetting("duik","ctrlSizeAutoValue"));			Duik.settings.boneType = eval(app.settings.getSetting("duik","boneType"));			Duik.settings.boneSize = eval(app.settings.getSetting("duik","boneSize"));			Duik.settings.boneSizeAuto = eval(app.settings.getSetting("duik","boneSizeAuto"));			Duik.settings.boneSizeHint = eval(app.settings.getSetting("duik","boneSizeAutoValue"));			Duik.settings.boneColor = app.settings.getSetting("duik","boneColor");			Duik.settings.morpherCreatesKeyframes = eval(app.settings.getSetting("duik","morpherKeyframes"));			Duik.settings.pasteAnimUseIndexes = eval(app.settings.getSetting("duik","pasteAnimUseIndexes"));		}				Duik.settings.restoreDefaults = function ()		{			Duik.settings.controllerSize = 100;			Duik.settings.controllerSizeAuto = true;			Duik.settings.controllerSizeHint = Duik.sizes.MEDIUM;			Duik.settings.boneType = Duik.layerTypes.SOLID;			Duik.settings.boneSize = 20;			Duik.settings.boneSizeAuto = true;			Duik.settings.boneSizeHint = Duik.sizes.MEDIUM;			Duik.settings.boneColor = "FF0000";			Duik.settings.morpherCreatesKeyframes = true;			Duik.settings.pasteAnimUseIndexes = false;						Duik.settings.save();		}				Duik.settings.load();	}		//================================	//========== UTILS ===============	//================================		if (typeof Duik.utils !== 'object')	{		Duik.utils = {};		// RIG PROPERTY - Duik.utils.rigProperty(layer,prop,effectMatchName)		if (typeof Duik.utils.rigProperty !== 'function')		{			Duik.utils.rigProperty = function (layer,prop,effectMatchName)			{				//if prop is an effect, need a way to recover it				var isEffect,effetIndex,effetProfondeur,effetParentName;				if (!Duik.utils.prepareProperty(prop,isEffect,effetIndex,effetProfondeur,effetParentName)) return null;								//pseudo effect				var effect = null;				if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(layer,effectMatchName);				else effect = layer.effect.addProperty(effectMatchName);				if (isEffect){ prop = layer.effect(effetParentName)(effetIndex); }								return effect;			}		}		// PREPARE PROPERTY - Duik.utils.prepareProperty(prop,isFX,ind,prof,parentName,dimensions)		if (typeof Duik.utils.prepareProperty !== 'function')		{			Duik.utils.prepareProperty = function (prop,isFX,ind,prof,parentName,dimensions)			{				if (!prop.canSetExpression) return false;				isFX = false;				if (prop.parentProperty.isEffect)				{					ind = prop.propertyIndex;					prof = prop.propertyDepth;					parentName = prop.parentProperty.name;					isFX = true;					dimensions = Duik.utils.getPropertyDimensions(prop);				}				return true;			}		}		// GET DIMENSIONS - Duik.utils.getPropertyDimensions(property)		if (typeof Duik.utils.getPropertyDimensions !== 'function')		{			Duik.utils.getPropertyDimensions = function (prop)			{				var dimensions = 1;				if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)				{					//if this is a position and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......					if (!prop.parentProperty.isEffect && prop.name.toLowerCase() == "position" && !app.project.activeItem.selectedLayers[0].threeDLayer)					{						dimensions = 2;					}					else					{						dimensions = 3;					}				}				else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)				{					dimensions = 2;				}				return dimensions;			}		}		// GET LENGTH - Duik.utils.getLength(value1,value2)		if (typeof Duik.utils.getLength !== 'function')		{			Duik.utils.getLength = function (value1,value2)			{				if (typeof value1 !== typeof value2)				{					return null;				}				if (value1.length > 0)				{					var result = 0;					for (var dim = 0;dim<value1.length;dim++)					{						result += (value1[dim]-value2[dim])*(value1[dim]-value2[dim]);					}					result = Math.sqrt(result);					return result;				}				else return Math.abs(value1 - value2) ;			}		}		// GET AVERAGE SPEED - Duik.utils.getAverageSpeed(layer,property)		if (typeof Duik.utils.getAverageSpeed !== 'function')		{			Duik.utils.getAverageSpeed = function (layer,prop)			{				if (prop.numKeys < 1) return 0;				//for each frame of the comp				var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;				var lastTime = prop.keyTime(prop.numKeys);				var firstTime = prop.keyTime(1);				var lastFrame = lastTime/layer.containingComp.frameDuration ;				var firstFrame = firstTime/layer.containingComp.frameDuration ;				if (lastFrame > frames) lastFrames = frames;				if (firstFrame < 1) firstFrame = 1;				var sum = 0;				for (var frame = firstFrame ; frame < lastFrame ; frame++)				{					var time = frame*app.project.activeItem.frameDuration;					sum += Duik.utils.getLength(prop.valueAtTime(time,false),prop.valueAtTime(time-layer.containingComp.frameDuration,false));				}				return sum/(lastFrame-firstFrame);			}		}		// ADD PSEUDO EFFECT - Duik.utils.addPseudoEffect(layer,pseudoEffectName)		if (typeof Duik.utils.addPseudoEffect !== 'function')		{			Duik.utils.addPseudoEffect = function (layer,preset)			{				//applyPreset is bugged and always applies presets on selected layers instead of the given one,				//first deselect everything and select the wanted layer				var selection = app.project.activeItem.selectedLayers;				Duik.utils.deselectLayers();				layer.selected = true;				var presetFile = new File(Duik.presetPath + preset + ".ffx");				layer.applyPreset(presetFile);								var newEffect = null;								for (var fx = 1;fx <= layer("Effects").numProperties;fx++)				{					if (layer.effect(fx).name == preset )					{						newEffect = layer.effect(fx);						break;					}				}								//restore selection...				layer.selected = false;				for (var selectedLayerIndex=0;selectedLayerIndex<selection.length;selectedLayerIndex++)				{					selection[selectedLayerIndex].selected = true;				}								return newEffect;			}		}		// GET ALL PUPPET PINS FROM A LAYER - Duik.utils.getPuppetPins(prop)		if (typeof Duik.utils.getPuppetPins !== 'function')		{			Duik.utils.getPuppetPins = function (prop) {				var coins = [];				if (prop != null)				{					if (prop.matchName == "ADBE FreePin3 PosPin Atom")					{						coins.push(prop);					}					else if (prop.numProperties > 0)					{						//contournement de bug...						//d'abord recup les propriétés dans un tableau avant de les parcourir						//sinon l'incrément fonctionne pas dans la boucle, allez savoir pourquoi						var proprietes = [];						for (var p=1;p<=prop.numProperties;p++)						{							proprietes.push(prop.property(p));						}						for (var pi = 0;pi < proprietes.length;pi++)						{							var newCoins = Duik.utils.getPuppetPins(proprietes[pi]);							if (newCoins.length > 0)							{								coins = coins.concat(newCoins);							}						}					}				}								return coins;			}		}		// MEASURE DISTANCE BETWEEN TWO LAYERS - Duik.utils.getDistance(layer1,layer2)		if (typeof Duik.utils.getDistance !== 'function')		{			Duik.utils.getDistance = function (layer1,layer2)			{				//parents				var layer1Parent = layer1.parent;				var layer2Parent = layer2.parent;					//unlink				layer1.parent = null;				layer2.parent = null;				var O = layer1.transform.position.value;				var A = layer2.transform.position.value;				var OA = Duik.utils.getLength(O,A);				//re-link				layer1.parent = layer1Parent;				layer2.parent = layer2Parent;				return Math.round(OA);			}		}		// DESELECT ALL LAYERS - Duik.utils.deselectLayers()		if (typeof Duik.utils.deselectLayers !== 'function')		{			Duik.utils.deselectLayers = function ()			{				var sel = app.project.activeItem.selectedLayers;				for (var selectedLayerIndex=0;selectedLayerIndex<sel.length;selectedLayerIndex++)				{					sel[selectedLayerIndex].selected = false;				}			}		}		// CHECK NAMES - Duik.utils.checkNames(comp)		if (typeof Duik.utils.checkNames !== 'function')		{			Duik.utils.checkNames = function (comp)			{				if (comp == undefined) comp = app.project.activeItem;				if (comp == undefined) return false;								var layers = comp.layers;				var numLayers = comp.numLayers;				var renamed = false;								var counts = {};				// first pass, assign the counts				for (var layerI = 1; layerI <= numLayers; layerI++)				{					var layer = layers[layerI];					var name = layer.name;					if (counts[name] == undefined)					{						counts[name] = 1;					}					else					{						counts[name]++;					}					if (counts[name] > 1)					{						var l = layer.locked;						layer.locked = false;						layer.name = name + " " + counts[name];						layer.locked = l;						renamed = true;					}				}								return renamed;			}		}		// GET ITEM from Array or Collection		if (typeof Duik.utils.getItem !== 'function')		{			Duik.utils.getItem = function (items,itemIndex)			{				if (items instanceof ItemCollection || items instanceof LayerCollection || items instanceof OMCollection || items instanceof RQItemCollection) return items[itemIndex+1];				else return items[itemIndex];			}		}		// GET KEY at index from property		//return KeyFrame		if (typeof Duik.utils.getKey !== 'function')		{			Duik.utils.getKey = function (prop,keyIndex)			{				if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)				{					return null;				}				if (keyIndex < 0)				{					keyIndex = prop.numKeys - keyIndex + 1;				}									var key = new KeyFrame();				key.time = prop.keyTime(keyIndex);				key.value = prop.keyValue(keyIndex);				key.inInterpolationType = prop.keyInInterpolationType(keyIndex);				key.outInterpolationType = prop.keyOutInterpolationType(keyIndex);				if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )				{					key.spatial = true;					key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);					key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);					key.spatialProperties.continuous = prop.keySpatialContinuous(keyIndex);					key.spatialProperties.autoBezier = prop.keySpatialAutoBezier(keyIndex);					key.spatialProperties.roving = prop.keyRoving(keyIndex);				}				key.inEase = prop.keyInTemporalEase(keyIndex);				key.outEase = prop.keyOutTemporalEase(keyIndex);				key.continuous = prop.keyTemporalContinuous(keyIndex);				key.autoBezier = prop.keyTemporalAutoBezier(keyIndex);					return key;			}		}		// GET PROPERTY ANIMS between startTime and Endtime (if propertyGroup, recursive)		//return Array of PropertyAnim		if (typeof Duik.utils.getPropertyAnims !== 'function')		{			Duik.utils.getPropertyAnims = function (prop,selectedKeysOnly,startTime,endTime)			{				var anims = [];				if (prop.propertyType == PropertyType.PROPERTY)				{					var anim = Duik.utils.getPropertyAnim(prop,selectedKeysOnly,startTime,endTime);					if (selectedKeysOnly && anim.keys.length >= 1) anims.push(anim);					else if (!selectedKeysOnly) anims.push(anim);				}				else if (prop.numProperties > 0)				{					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)					{						var newAnims = Duik.utils.getPropertyAnims(prop.property(propIndex),selectedKeysOnly,startTime,endTime);						if (newAnims.length > 0)						{							anims = anims.concat(newAnims);						}					}				}				return anims;			}		}		// GET PROPERTY ANIM between startTime and Endtime (not for PropertyGroup)		//return PropertyAnim		if (typeof Duik.utils.getPropertyAnim !== 'function')		{			Duik.utils.getPropertyAnim = function (prop,selectedKeysOnly,startTime,endTime)			{				var anim = new PropertyAnim();				anim.name = prop.name;				anim.startValue = prop.valueAtTime(startTime,true);									if (prop.elided) return anim;								if (prop.isTimeVarying)				{					if (selectedKeysOnly)					{						for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)						{							var key = Duik.utils.getKey(prop,prop.selectedKeys[keyIndex]);							if (key.time >= startTime && key.time <= endTime)							{								key.time = key.time - startTime;								anim.keys.push(key);							}						}					}					else if (prop.numKeys > 0)					{						for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)						{							var time = prop.keyTime(keyIndex);							if (time >= startTime && time <= endTime)							{								var key = Duik.utils.getKey(prop,keyIndex);								key.time = key.time - startTime;								anim.keys.push(key);							}						}					}				}				return anim;			}		}		// SET PROPERTY ANIM		//return boolean		if (typeof Duik.utils.setPropertyAnim !== 'function')		{			Duik.utils.setPropertyAnim = function (prop,propAnim,startTime)			{									var name = propAnim.name;				//trouver la propriété portant ce nom dans la prop demandée				if (prop.propertyType == PropertyType.PROPERTY && prop.name == name && !prop.elided)				{					//if there are keys, paste them					if (propAnim.keys.length > 0)					{						for (var iclef = 0; iclef < propAnim.keys.length;iclef++)						{							Duik.utils.addKey(prop,propAnim.keys[iclef],startTime);						}					}					else //set the start value					{						try { prop.setValue(propAnim.startValue); }						catch(err){}					}					return true;				}				else if (prop.numProperties != undefined)				{					if (prop.numProperties > 0)					{						for (var pi = 1;pi <= prop.numProperties;pi++)						{							if (Duik.utils.setPropertyAnim(prop.property(pi),propAnim,startTime)) return true;						}					}				}				return false;			}		}		// ADD KEY		//return void		if (typeof Duik.utils.addKey !== 'function')		{			Duik.utils.addKey = function (prop,key,startTime)			{					if (prop.elided) return;				var time = startTime+key.time;				try //au cas où on est sur du XPosition alors que le calque est 2D, par exemple				{					prop.setValueAtTime(time,key.value); 					//get the index of the created key					var index = prop.nearestKeyIndex(time);					if (key.spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))					{						prop.setSpatialContinuousAtKey(index,key.spatialProperties.continuous);						prop.setSpatialAutoBezierAtKey(index,key.spatialProperties.autoBezier);						prop.setRovingAtKey(index,key.spatialProperties.roving);						prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);					}					prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);					prop.setTemporalContinuousAtKey(index,key.continuous);					prop.setTemporalAutoBezierAtKey(index,key.autoBezier);					prop.setInterpolationTypeAtKey(index,key.inInterpolationType,key.outInterpolationType);									}				catch (err)				{}			}		}		// GET FIRST KEYTIME in PropertyGroup (recursive)		//return int		if (typeof Duik.utils.getFirstKeyTime !== 'function')		{			Duik.utils.getFirstKeyTime = function (prop)			{				var firstKeyTime = 86339;								if (prop.propertyType == PropertyType.PROPERTY)				{					if (prop.selectedKeys.length > 0)					{						for (var key = 0;key<prop.selectedKeys.length;key++)						{							if (prop.keyTime(prop.selectedKeys[key]) < firstKeyTime)							{								firstKeyTime = prop.keyTime(prop.selectedKeys[key]);							}						}					}				}				else if (prop.numProperties > 0)				{					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)					{						testKeyTime = Duik.utils.getFirstKeyTime(prop.property(propIndex));						if (testKeyTime < firstKeyTime) firstKeyTime = testKeyTime;					}				}				return firstKeyTime;			}		}		// ARE THERE SELECTED KEYS in PropertyGroup		//return boolean		if (typeof Duik.utils.areThereSelectedKeys !== 'function')		{			Duik.utils.areThereSelectedKeys = function (prop)			{				var yes = false;								if (prop.propertyType == PropertyType.PROPERTY)				{					if (prop.selectedKeys.length >0)					{						yes = true;					}				}				else if (prop.numProperties > 0)				{					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)					{						yes = Duik.utils.areThereSelectedKeys(prop.property(propIndex));						if (yes) break;					}				}				return yes;			}		}	}		//================================	//========= METHODS ==============	//================================		//TODO, instead of returning true or false, functions should return the effect created		/*	ADD IK - Duik.IK(controller,layer1,layer2,layer3,goal,clockWise,threeD,frontFacing)		adds a 2D IK to the layers controlled by controller				parameters:		controller | AVLayer		layer1 | AVLayer		layer2 | AVLayer or undefined		layer3 | AVLayer or undefined		goal | AVLayer or undefined		clockWise | boolean, used only with two-layer and three-layer IK, default: false		threeD | boolean, works only with two-layer IK, default: false		frontFacing | boolean, default: false						returns		true if successful, false if anything went wrong	*/	if (typeof Duik.IK !== 'function')	{		Duik.IK = function (ctrl,layer1,layer2,layer3,goal,cw,threeD,frontFacing)		{				//if there's not at least one controller and one layer, abort creation			if (ctrl == undefined || layer1 == undefined) return false;						if (cw == undefined) cw = false;			if (threeD == undefined) threeD = false;			if (frontFacing == undefined) frontFacing = false;						var zero = null;						if (layer2 == undefined && layer3 == undefined)			{				var ok = Duik.oneLayerIK(ctrl,layer1);				if (!ok) return false;				if (goal != undefined)				{					var ok = Duik.addGoal(goal,ctrl);					return ok;				}			}			else if (layer3 == undefined)			{				zero = Duik.twoLayerIK(threeD,ctrl,layer1,layer2,cw);				if (zero == null) return false;			}			else			{				threeD = false;				var zero = Duik.threeLayerIK(ctrl,layer1,layer2,layer3,cw);				if (zero == null) return false;			}						if (zero != null && goal != undefined)			{				var ok = Duik.goal(goal,ctrl);				if (!ok) return false;				//link the position in case of stretch				goal.transform.position.expression = "thisComp.layer(\"" + zero.name + "\").transform.position;";							}							return true;		}	}	// ADD ONE-LAYER IK - Duik.oneLayerIK(controller,layer)	if (typeof Duik.oneLayerIK !== 'function')	{		Duik.oneLayerIK = function (ctrl,layer1)		{			//if there's not at least one controller and one layer, abort creation			if (ctrl == undefined || layer1 == undefined) return false;						//check names			Duik.utils.checkNames(ctrl.containingComp);								var controllerName = ctrl.name;						//pseudo effect			var effect;			if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(ctrl,"DUIK_One_Layer_IK");			else effect = ctrl.effect.addProperty("DUIK_One_Layer_IK");			effect.name = Duik.uiStrings.ik + " "  + layer1.name;									//rotation d'origine			var orot = layer1.transform.rotation.value;			//=========================================================			//EXPRESSION TO INSERT			var expression = "//Duik.oneLayerIK\r\n" + 			"CName = \"" + controllerName + "\";\r\n" +			"C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\r\n" +			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\r\n" +			"W = thisComp.layer(CName).effect(\"" + effect.name + "\")(1)/100;\r\n" + 			"FK = thisComp.layer(CName).effect(\"" + effect.name + "\")(3);\r\n" +			"R = thisComp.layer(CName).effect(\"" + effect.name + "\")(2);\r\n" + 			"angle = lookAt(C,O);\r\n" +			"angle = angle*W;\r\n" +			"R == 1 ? angle = -angle : angle;\r\n" +			"var result;\r\n" +			"angle[0] > 0 ? result = angle[0]+angle[1]+FK+value : result = angle[0]-angle[1]+FK+value;\r\n" +			"var layer = thisLayer;\r\n" +			"while (layer.hasParent)\r\n" +			"{\r\n" +			"layer = layer.parent;\r\n" +			"result = result - layer.rotation;\r\n" +			"}\r\n" +			"result;";			//=========================================================			layer1.transform.rotation.expression = expression;						//nouvelle rotation			var nrot = layer1.transform.rotation.value;			layer1.transform.rotation.setValue(-nrot+2*orot);						//select controller			Duik.utils.deselectLayers();			ctrl.selected = true;						return true;		}	}	// ADD TWO-LAYER IK - Duik.twoLayerIK(threeD,controller,root,end,clockWise,frontFacing)	if (typeof Duik.twoLayerIK !== 'function')	{		Duik.twoLayerIK = function (threeD,controller,root,end,clockWise,frontFacing)		{			//if there's not at least one controller and two layers, abort creation			if (controller == undefined || root == undefined || end == undefined) return false;						if (clockWise == undefined) clockWise = false;			if (frontFacing == undefined) frontFacing = false;						//check names			Duik.utils.checkNames(controller.containingComp);						//Names			var endName = end.name;			var rootName = root.name;			var controllerName = controller.name;						//pseudo effect			var effect;			if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(controller,"DUIK_Two_Layer_IK");			else effect = controller.effect.addProperty("DUIK_Two_Layer_IK");			effect.name = Duik.uiStrings.ik + " "  + endName;			if (clockWise) effect(1).setValue(1);			if (threeD) {				direction = controller.Effects.addProperty("ADBE Angle Control");				direction.name = "IK Direction " +  rootName.slice(-15);			}								//créer un zéro			endZero = app.project.activeItem.layers.addNull();			endZero.threeDLayer = true;			var controllerParent = controller.parent;			controller.parent = null;			endZero.position.setValue(controller.position.value);			endZero.name = "IK_zero " + endName.slice(-24);			controller.parent = controllerParent;				//lier le zéro au bone du bout			endZero.parent = end;			//verrouiller et masquer le zéro			endZero.moveToEnd();			endZero.guideLayer = true;			endZero.locked = true;			endZero.enabled = false;			endZero.shy = true;			endZeroName = endZero.name;			//=========================================================			//EXPRESSION A INSERER SUR LE BONE BOUT			var endExpression = "//Duik.twoLayerIK\r\n" +				"boneracine = \"" + rootName + "\";\n" + 				"bonebout = \"" + endName + "\";\n" + 				"zero = \"" + endZeroName + "\";\n" + 				"controleur = \"" + controllerName + "\";\n" +				"FK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(5);\n" +				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +				"if (thisComp.layer(controleur).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" +				"function getWorldPos(theLayerName){\n" + 				"  L = thisComp.layer(theLayerName);\n" + 				"  return L.toWorld(L.anchorPoint);\n" + 				"}\n" + 				"function oriente(a, b, P) {\n" +				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +				"}\n" +				"A = getWorldPos(boneracine);\n" + 				"B = getWorldPos(bonebout);\n" + 				"C = getWorldPos(zero);\n" + 				"E = getWorldPos(controleur);\n" + 				"a = length(B,C);\n" + 				"b = length(E,A);\n" + 				"c = length(A,B);\n" + 				"x = (b*b + c*c - a*a )/(2*b);\n" + 				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 				"y = b - x;\n" + 				"  gamma = Math.acos(clamp(y/a,-1,1));\n" + 				"result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);" +				"  V1 = B - A;\n" + 				"  adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n" + 				"  V2 = C - B;\n" + 				"  adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n" + 				"  IK = result +  adj1 - adj2 + value;\n" + 				"IKFK ? IK : FK;";			//=========================================================			threeD ? end.transform.zRotation.expression = endExpression : end.transform.rotation.expression = endExpression;			//=========================================================			//EXPRESSION A INSERER SUR LE BONE RACINE			var rootExpression = "//Duik.twoLayerIK\r\n" +				"boneracine = \"" + rootName + "\";\n" + 				"bonebout = \"" + endName + "\";\n" + 				"zero = \"" + endZeroName + "\";\n" + 				"controleur = \"" + controllerName + "\";\n" +				"FK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(4);\n" +				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +				"if (thisComp.layer(controleur).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" +				"function getWorldPos(theLayerName){\n" + 				"  L = thisComp.layer(theLayerName);\n" + 				"  return L.toWorld(L.anchorPoint);\n" + 				"}\n" + 				"function oriente(a, b, P) {\n" +				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +				"}\n" +				"A = getWorldPos(boneracine);\n" + 				"B = getWorldPos(bonebout);\n" + 				"C = getWorldPos(zero);\n" + 				"E = getWorldPos(controleur);\n" + 				"a = length(B,C);\n" + 				"b = length(E,A);\n" + 				"c = length(A,B);\n" + 				"x = (b*b + c*c - a*a )/(2*b);\n" + 				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 				"D = E - A;\n" + 				"delta = Math.atan2(D[1],D[0]);\n" + 				"result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n" +				"V = B - A;\n" + 				"adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n" + 				"IK = result - adj1 + value;\n" + 				"IKFK ? IK : FK;";			//=======================================================			threeD ? root.transform.zRotation.expression = rootExpression : root.transform.rotation.expression = rootExpression;			if (threeD) {				//si 3D : le zéro de la jambe pour l'orientation				//créer un zéro				var zero = app.project.activeItem.layers.addNull();				zero.threeDLayer = true;				var calqueparent = root.parent;				root.parent = null;				zero.position.setValue(root.position.value);				zero.name = "Zero_" + rootName.slice(-24);				//verrouiller et masquer le zéro				zero.moveToEnd();				zero.guideLayer = true;				zero.shy = true;				if (frontFacing) {					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 						"C = controleur.toWorld(controleur.anchorPoint);\n" +						"Cx = C[0];\n" +						"Cy = C[1];\n" +						"Cz = C[2];\n" +						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +						"Lx = L[0];\n" +						"Ly = L[1];\n" +						"Lz = L[2];" +						"angle = lookAt([Cz,Cy,Cx],[Lz,Ly,Lx]);\n" +						"[-angle[1]+90,-angle[0],value[2]]\n"				} else { //front					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 						"C = controleur.toWorld(controleur.anchorPoint);\n" +						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +						"angle = lookAt(C,L);\n" +						"[angle[0],angle[1],value[2]]\n"				} //else front				zero.transform.orientation.expression = zeroExpression;				zero.transform.xRotation.expression = "//Duik.twoLayerIK.threeD\r\n" + "thisComp.layer(\"" + controllerName + "\").effect(\"IK Direction " +  rootName.slice(-15) + "\")(1)";				root.parent = zero;				//lier le zéro au bone du bout				zero.parent = calqueparent;				zero.enabled = false;				zero.locked = true;			} //tridi			//les expressions de stretch			//les positions d'origine			var posbout = end.transform.position.value.toString();			var poszero = endZero.transform.position.value.toString();			var apracine = root.transform.anchorPoint.value.toString();			var apbout = end.transform.anchorPoint.value.toString();			var expressionstretchbout = "//Duik.twoLayerIK.stretch\r\n" +				"boneracine = \"" + rootName + "\";\n" + 				"controleur = \"" + controllerName + "\";\n" + 				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(9)/2;\n" + 				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(8);\n" +				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +				"function getWorldPos(theLayerName){\n" + 				"L = thisComp.layer(theLayerName);\n" + 				"return L.toWorld(L.anchorPoint);\n" + 				"}\n" + 				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 				"proportion = dist1/(dist1+dist2);\n" + 				"posC = getWorldPos(controleur);\n" + 				"posR = getWorldPos(boneracine);\n" + 				"distC = length(posC,posR);\n" + 				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 				"else stretch = stretch*proportion;\n" + 				"coef = 1;\n" + 				"dist1 != 0 ? coef = (dist1+stretch)/dist1 : coef = 1;\n" +				"([" + posbout + "]-[" + apracine + "])*coef+[" + apracine + "];";			end.transform.position.expression = expressionstretchbout;			var expressionstretchzero = "//Duik.twoLayerIK.stretch\r\n" +				"boneracine = \"" + rootName + "\";\n" + 				"controleur = \"" + controllerName + "\";\n" + 				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(9)/2;\n" + 				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(8);\n" +				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +				"function getWorldPos(theLayerName){\n" + 				"L = thisComp.layer(theLayerName);\n" + 				"return L.toWorld(L.anchorPoint);\n" + 				"}\n" + 				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 				"proportion = dist2/(dist1+dist2);\n" + 				"posC = getWorldPos(controleur);\n" + 				"posR = getWorldPos(boneracine);\n" + 				"distC = length(posC,posR);\n" + 				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 				"else stretch = stretch*proportion;\n" + 				"coef = 1;\n" + 				"dist2 != 0 ? coef = (dist2+stretch)/dist2 : coef = 1;\n" +				"([" + poszero + "]-[" + apbout + "])*coef+[" + apbout + "];";			endZero.transform.position.expression = expressionstretchzero;						//select controller			Duik.utils.deselectLayers();			controller.selected = true;						return endZero;		}	}	/* ADD GOAL - Duik.goal(layer,controller)		adds a goal to the layer which may be controlled by a controller				parameters:		layer	| AVLayer		controller | AVLayer or undefined					returns		true if successful, false if anything went wrong		*/	if (typeof Duik.goal !== 'function')	{		Duik.goal = function (layer,controller)		{			//pour ne pas bouger, il faut récupérer la rotation d'origine			var ancienneRot = 0;			if (layer.threeDLayer) ancienneRot = layer.transform.zRotation.value;			else ancienneRot = layer.transform.rotation.value;						//check names			Duik.utils.checkNames(layer.containingComp);			//si on a un controleur			if (controller != undefined)			{				//ajouter la case sur le controleur				var effetGoal = controller.Effects.addProperty("ADBE Checkbox Control");				effetGoal.name = "Goal" + " " + layer.name;				effetGoal(1).setValue(true);				//ajouter l'expression dans le calque				expr = "//Duik.goal\r\n" +					"var C = thisComp.layer('" + controller.name + "');\r\n" + 					"var goal = C.effect('" + effetGoal.name + "')(1);\r\n" + 					"var result = value + C.rotation;\r\n" + 					"if (goal == 1)\r\n" + 					"{\r\n" + 					"var layer = thisLayer;\r\n" + 					"while (layer.hasParent)\r\n" + 					"{\r\n" + 					"layer = layer.parent;\r\n" + 					"result = result - layer.rotation;\r\n" + 					"}\r\n" + 					"}\r\n" + 					"result;";						if (layer.threeDLayer) layer.transform.zRotation.expression = expr;				else layer.transform.rotation.expression = expr;			}			else			{				//ajouter la case sur le calque				var effetGoal = layer.Effects.addProperty("ADBE Checkbox Control");				effetGoal.name = "Goal";				effetGoal(1).setValue(true);				//ajouter l'expression dans le calque				layer.transform.rotation.expression = "//Duik.goal\r\n" +					"var goal = thisLayer.effect('" + effetGoal.name + "')(1);\r\n" + 					"var result = value;\r\n" + 					"if (goal == 1)\r\n" + 					"{\r\n" + 					"var layer = thisLayer;\r\n" + 					"while (layer.hasParent)\r\n" + 					"{\r\n" + 					"layer = layer.parent;\r\n" + 					"result = result - layer.rotation;\r\n" + 					"}\r\n" + 					"}\r\n" + 					"result;";			}				//et remettre la bonne rotation pour pas bouger			var nouvelleRot = 0;			if (layer.threeDLayer) nouvelleRot = layer.transform.zRotation.value;			else nouvelleRot = layer.transform.rotation.value;			if (layer.threeDLayer) layer.transform.zRotation.setValue(2*ancienneRot-nouvelleRot);			else layer.transform.rotation.setValue(2*ancienneRot-nouvelleRot);						//select controller			if (controller != undefined)			{				Duik.utils.deselectLayers();				controller.selected = true;			}						return true;		}	}	/* ADD CONTROLLER - Duik.addController(layer)			parameters		layer | AVLayer				returns		AVLayer controller	*/	if (typeof Duik.addController !== 'function')	{		Duik.addController = function (layer)		{			var layerParent = layer.parent;			layer.parent = null;			var layerPosition = layer.transform.position.value;			layer.parent = layerParent;			//le controleur			var controller = app.project.activeItem.layers.addNull();			var controllerSize = Duik.settings.controllerSize;			if (Duik.settings.controllerSizeAuto) {				controllerSize = app.project.activeItem.width/2 + app.project.activeItem.height/2;				if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40);				else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20);				else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10);			}			controller.source.width = controllerSize;			controller.source.height = controllerSize;			controller.anchorPoint.setValue([controller.source.width/2,controller.source.height/2]);			controller.transform.position.setValue(layerPosition);			controller.name = "C_" + layer.name.slice(-28);						//select controller			Duik.utils.deselectLayers();			controller.selected = true;			return controller;		}	}	/* ADD CONTROLLERS - Duik.addControllers(layers)				parameters		layers | Array of AVLayer				returns		true if successful, false if anything went wrong	*/	if (typeof Duik.addControllers !== 'function')	{		Duik.addControllers = function (layers)		{			var controllers = [];						for (var i = 0 ; i < layers.length ; i++)			{				controllers.push ( Duik.addController( Duik.utils.getItem(layers,i) ) );			}			//select controllers			Duik.utils.deselectLayers();			for (var controllerI = 0; controllerI < controllers.length;controllerI++)			{				controllers[controllerI].selected = true;			}						return controllers;		}	}	/* ADD WIGGLE - Duik.wiggle(layer,property,separateDimensions)		Adds a wiggle effect on the property of the layer			parameters		layer | AVLayer		property | Property		separateDimensions | boolean, default: false				returns		true if successful, false if anything went wrong	*/	if (typeof Duik.wiggle !== 'function')	{		Duik.wiggle = function (layer,prop,separateDimensions)		{			if (!prop.canSetExpression) return false;						if (separateDimensions == undefined) separateDimensions = false;						//dimensions			var dimensions = Duik.utils.getPropertyDimensions(prop);			if (!separateDimensions) dimensions = 1;						var ok = false;						if (dimensions == 3) ok = Duik.threeDWiggle(layer,prop);			else if (dimensions == 2) ok = Duik.twoDWiggle(layer,prop);			else ok = Duik.oneDWiggle(layer,prop);						return ok;		}	}	// ADD 3D WIGGLE - Duik.threeDWiggle(layer,property,x,y,z)	if (typeof Duik.threeDWiggle !== 'function')	{		Duik.threeDWiggle = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_3D_Wiggle");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.wiggle;						prop.expression = "//Duik.3DWiggle\r\nX=wiggle(effect(\"" + effect.name + "\")(7),effect(\"" + effect.name + "\")(2));\n" + "Y=wiggle(effect(\"" + effect.name + "\")(8),effect(\"" + effect.name + "\")(3));\n" + "Z=wiggle(effect(\"" + effect.name + "\")(9),effect(\"" + effect.name + "\")(4));\n" +  "[X[0],Y[1],Z[2]]";					return true;		}	}	// ADD 2D WIGGLE - Duik.twoDWiggle(layer,property)	if (typeof Duik.twoDWiggle !== 'function')	{		Duik.twoDWiggle = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_2D_Wiggle");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.wiggle;			prop.expression = "//Duik.2DWiggle\r\nX=wiggle(effect(\"" + effect.name + "\")(6),effect(\"" + effect.name + "\")(2));\n" + "Y=wiggle(effect(\"" + effect.name + "\")(7),effect(\"" + effect.name + "\")(3));\n" +  "[X[0],Y[1]]";						return true;		}	}	// ADD 1D WIGGLE - Duik.1DWiggle(layer,property)	if (typeof Duik.oneDWiggle !== 'function')	{		Duik.oneDWiggle = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_1D_Wiggle");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.wiggle;						prop.expression = "//Duik.1DWiggle\r\nwiggle(effect(\"" + effect.name + "\")(2),effect(\"" + effect.name + "\")(1))";						return true;		}	}	/* EXPOSURE - Duik.exposure(layer,property,adaptative,limit,minExp,maxExp);			Adds exposure controls to the animation of the property			parameters		layer | AVLayer		property | Property		adaptative | boolean, default: true				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.exposure !== 'function')	{		Duik.exposure = function (layer,prop,adaptative,limit,minExp,maxExp)		{			if (adaptative == undefined) adaptative = true;						var ok = false;						if (adaptative) ok = Duik.adaptativeExposure(layer,prop,limit,minExp,maxExp);			else ok = Duik.fixedExposure(layer,prop);						return ok;		}	}	// ADAPTATIVE EXPOSURE - Duik.adaptativeExposure(layer,property,precision,minExp,maxExp);	if (typeof Duik.adaptativeExposure !== 'function')	{		Duik.adaptativeExposure = function (layer,prop,limit,minExp,maxExp)		{			if (!prop.canSetExpression) return false;			if (prop.numKeys < 1) return false;						if (minExp == undefined) minExp = 1;			if (maxExp == undefined) maxExp = 4;						if (minExp <= 0) minExp = 1;			if (maxExp <= 0) maxExp = 1;						if (limit == undefined) limit = 100;			if (limit == 0) limit = 1;						limit = 1/limit*10000;								//for each frame of the comp			var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;			for (var frame = 0 ; frame < frames ; frame += minExp)			{				var time = frame*app.project.activeItem.frameDuration;				var nearKey = prop.nearestKeyIndex(time);				var nearKeyTime = prop.keyTime(nearKey);									if (time <= nearKeyTime && nearKey == 1) continue;								//get the value of the previous key				var prevKey = 0;				if (time < nearKeyTime) prevKey = nearKey -1;				else prevKey = nearKey;								if (prevKey == prop.numKeys) break;    								var prevKeyValue = prop.keyValue(prevKey);				var prevKeyTime = prop.keyTime(prevKey);								//set a new key				var speed = Duik.utils.getLength(prop.valueAtTime(time,false),prop.keyValue(prevKey));				var exposure = (time - prevKeyTime) / app.project.activeItem.frameDuration;								if (speed >= limit || exposure >= maxExp) prop.addKey(time);							}			//all key interpolations to HOLD			for (var keyIndex = 1;keyIndex <= prop.numKeys;keyIndex++)			{				prop.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);							}						return true;		}	}	// ADAPTATIVE EXPOSURE - Duik.fixedExposure(layer,property);	if (typeof Duik.fixedExposure !== 'function')	{		Duik.fixedExposure = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_Exposure");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.exposure;			effect(1).setValue(1);						prop.expression = "expo = effect(\"" + effect.name + "\")(1);\n" +			"expo == 0 ? expo = 1 : Math.abs(expo);\n" +			"timef = timeToFrames(time);\n" +			"valueAtTime(framesToTime( timef - timef%expo ))";		}	}	/* ADD BONES - Duik.addBones(layers);			Adds bones to the layers, only on selected pins if any, or else on all puppet pins found on those layers.			parameters		layers | Array of AVLayer				returns		Array of AVLayers, the bones created		*/	if (typeof Duik.addBones !== 'function')	{		Duik.addBones = function (layers)		{			var createdBones = [];			if (layers.length == 0) { return createdBones; }						//check names			Duik.utils.checkNames(layers[0].containingComp);						for (var i=0;i<layers.length;i++)			{				var calque = Duik.utils.getItem(layers,i);				// les propriétés sélectionnées				var props = calque.selectedProperties;				var coins = [];				//lister les puppet pins				if (props.length > 0)				{					for (var j=0;j<props.length;j++)					{						if (props[j].matchName == "ADBE FreePin3 PosPin Atom") coins.push(props[j]);					}				}				//si il n'y a pas de coins sélectionnés, on les prend tous				if (coins.length == 0) coins = Duik.utils.getPuppetPins(calque("Effects"));				if (coins.length == 0) { return createdBones; }								for (var j=0;j<coins.length;j++)				{					var coin = coins[j];					//la position du coin					var position = coin.position.value;					//créer le bone					var bone;					//sa taille					boneTaille = Duik.settings.boneSize;					if (Duik.settings.boneSizeAuto) {						boneTaille = app.project.activeItem.width/2 + app.project.activeItem.height/2;						if (Duik.settings.boneSizeHint == Duik.sizes.SMALL) boneTaille = Math.floor(boneTaille/60);						else if (Duik.settings.boneSizeHint == Duik.sizes.MEDIUM) boneTaille = Math.floor(boneTaille/40);						else if (Duik.settings.boneSizeHint == Duik.sizes.BIG) boneTaille = Math.floor(boneTaille/20);					}					if (Duik.settings.boneType == Duik.layerTypes.NULL)					{						bone = app.project.activeItem.layers.addNull();						bone.name = "B_" + coin.name;						bone.source.width = boneTaille;						bone.source.height = boneTaille;						bone.transform.anchorPoint.setValue([bone.source.width/2,bone.source.height/2]);					}					else					{						var colorString = Duik.settings.boneColor;						var red = parseInt(colorString.substr(0,2),16)/255.0;						var green = parseInt(colorString.substr(2,2),16)/255.0;						var blue = parseInt(colorString.substr(4,2),16)/255.0;						bone = app.project.activeItem.layers.addSolid([red,green,blue],"B_" + coin.name,boneTaille,boneTaille,app.project.activeItem.pixelAspect);					}					createdBones.push(bone);					//mettre le bone à la position du coin : utiliser une expression pour avoir la position en mode world du coin					var filet = coin.propertyGroup().propertyGroup();					var marionnette = filet.propertyGroup().propertyGroup().propertyGroup();					if (calque instanceof ShapeLayer)					{						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").effect(\"" + marionnette.name + "\").arap.mesh(\"" + filet.name + "\").deform(\"" + coin.name + "\").position";					}					else					{						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").toWorld(thisComp.layer(\"" + calque.name + "\").effect(\"" + marionnette.name + "\").arap.mesh(\"" + filet.name + "\").deform(\"" + coin.name + "\").position)";					}					bone.position.setValue(bone.position.value);					bone.position.expression = "";					//nom du bone					bone.name = "B_" + coin.name;					bone.guideLayer = true;					//mettre l'expression dans le coin					if (calque instanceof ShapeLayer)					{						coin.position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint)";					}					else					{						coin.position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint);\nfromWorld(bonePos)";					}				}//for coins			}//for layers												return createdBones;		}	}	// ADD ZERO - Duik.addZero(layer);	if (typeof Duik.addZero !== 'function')	{		Duik.addZero = function (layer)		{			//create null object			var zero = layer.containingComp.layers.addNull();			var calqueparent = layer.parent;			layer.parent = null;			zero.position.setValue(layer.position.value);			zero.rotation.setValue(layer.rotation.value);			zero.name = "Zero_" + layer.name.slice(-24);			layer.parent = zero;			//parent			zero.parent = calqueparent;			//lock and hide			zero.moveToEnd();			zero.guideLayer = true;			zero.locked = true;			zero.shy = true;			zero.enabled = false;						return zero;		}	}	/* ADD ZEROS - Duik.addZeros(layers);			Adds a null object for each layer, at the same place and orientation,		and then parents the layer to it, parenting the null object (the zero) to the former		parent of the layer.			parameters		layers | Array of AVLayer				returns		Array of AVLayers, the zeros created		*/	if (typeof Duik.addZeros !== 'function')	{		Duik.addZeros = function (layers)		{			var zeros = [];			for (var i = 0 ; i < layers.length ; i++)			{				var calque = Duik.utils.getItem(layers,i);				var zero = Duik.addZero(calque);				zeros.push(zeros);			}			return zeros;		}	}	/* ROTATION MORPH - Duik.rotationMorph(layer,prop);			Creates a rotation morph on the given property			parameters		layer | AVLayer		prop | Property				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.rotationMorph !== 'function')	{		Duik.rotationMorph = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_RotMorph");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.rotMorph;						prop.expression = "//Duik.rotationMorph\r\n" + 								"if (numKeys > 1)\r\n" + 								"{\r\n" + 								"r = thisLayer.effect('" + effect.name + "')(1).transform.rotation;\r\n" + 								"n = timeToFrames(key(numKeys).time);\r\n" + 								"Min =  thisLayer.effect('" + effect.name + "')(2);\r\n" + 								"Max = thisLayer.effect('" + effect.name + "')(3);\r\n" + 								"div =  (Max - Min) / n;\r\n" + 								"val = 0;\r\n" + 								"if (div != 0) val = r/div - (Min/div);\r\n" + 								"valueAtTime(framesToTime(val));\r\n" + 								"} else value;";						return true;		}	}	/* SWING - Duik.swing(layer,prop);			Creates a swing on the given property			parameters		layer | AVLayer		prop | Property				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.swing !== 'function')	{		Duik.swing = function (layer,prop)		{			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_Swing");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.swing;			effect(1).setValue(10);			effect(2).setValue(1);						prop.expression = "//Duik.swing\r\n" + 								"amp = effect('" + effect.name + "')(1);\n" +								"freq = effect('" + effect.name + "')(2)*2*Math.PI;\n" +								"decalage = framesToTime(effect('" + effect.name + "')(3));\n" +								"amorti = Math.abs(effect('" + effect.name + "')(4));\n\n" +								"sin = Math.sin(time*freq+decalage);\n\n" +								"for(i=0;i<amorti;i++) {\n" +								"sin = Math.sin(sin);\n" +								"}\n" +								"sin*amp+value;";						return true;		}	}	/* WHEEL - Duik.wheel(layer,radius,curved);			Automates the rotation of the given layer using its position.		If curved, works even if the trajectory is not horizontal, but is heavier to compute.			parameters		layer | AVLayer		radius | float, default 100.0		curved | boolean, default false				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.wheel !== 'function')	{		Duik.wheel = function (layer,radius,curved)		{			if (radius == undefined) radius = 100;			else if (! (radius > 0)) radius = 100;			if (curved == undefined) curved = false;			var effect = Duik.utils.rigProperty(layer,layer.transform.rotation,"DUIK_Wheel");			if (effect == null) return false;			effect.name = Duik.uiStrings.wheel;			effect(1).setValue(radius);						if (!curved) layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 																"O = thisLayer.toWorld(thisLayer.anchorPoint);\n" + 																"R = thisLayer.effect('" + effect.name + "')(1);\n" + 																"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 																"result = 0;\n" +																"R > 0 ? result = radiansToDegrees(O[0]/R) : result = 0 ;" +																"Rev == 1 ? value - result : value + result;";			else layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 															"R = thisLayer.effect('" + effect.name + "')(1);\n" + 															"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 															"var precision = 1;\n" + 															"function pos(frame)\n" + 															"{\n" + 															"return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n" + 															"}\n" + 															"function roue()\n" + 															"{\n" + 															"if (R<=0) return value;\n" + 															"var distance = 0;\n" + 															"var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n" + 															"var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n" + 															"for(i=start;i<end;i+=precision)\n" + 															"{\n" + 															"if (pos(i+precision)[0] - pos(i)[0] > 0) distance += length(pos(i+precision),pos(i));\n" + 															"else distance -= length(pos(i+precision),pos(i));\n" + 															"}\n" + 															"return radiansToDegrees(distance/R) ;\n" + 															"}\n" + 															"Rev == 1 ? value - roue() : value + roue();";						return true;		}	}	/* MORPHER - Duik.morpher(layers);			Adds a "morpher", a slider to easily control interpolations of selected properties of the given layers.			parameters		layers | Array of AVLayer				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.morpher !== 'function')	{		Duik.morpher = function (layers)		{			//récupérer la sélection d'effets du premier calque, puisqu'elle sera perdue à la création de la glissière..... (voir avec adobe si vous trouvez ca pas pratique)			var selection = [];			var effets = Duik.utils.getItem(layers,0).selectedProperties;						for (var j=0;j<effets.length;j++) {			if (effets[j].canSetExpression && effets[j].parentProperty.isEffect) {				 var layerIndex = app.project.activeItem.selectedLayers[0].index;				 var effetIndex =  effets[j].propertyIndex;				 var effetParentName = effets[j].parentProperty.name;				selection.push([layerIndex,effetParentName,effetIndex]);				delete effetIndex;				delete effetParentName;				}			}			//créer le curseur			var morpher = layers[0].Effects.addProperty("ADBE Slider Control");			morpher.name = "Morpher";			//boucle pour appliquer le morpher sur la sélection perdue			for (var i=0;i<selection.length;i++)			{				var effet = layers[0].effect(selection[i][1])(selection[i][2]);				effet.expression = "//Duik.Morpher\r\nvalueAtTime((thisComp.layer(\"" +  layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";				//la boucle pour créer automatiquement des clefs sur le morpher :				if (Duik.settings.morpherCreatesKeyframes)				{					//nombre de clefs					var nbreClefs = effet.numKeys;					//durée d'image de la compo					var ips = app.project.activeItem.frameDuration;					var temps = 0;					var prop = effet;					for (var k=1;k<=nbreClefs;k++)					{                 						//récupère l'instant de la clef						temps = prop.keyTime(k);						//crée une image clef sur le morpher						morpher(1).setValueAtTime(temps,temps/ips);					}					delete temps;					delete prop;					delete ips;					delete nbreClefs;   				}			}			//boucle pour appliquer le morpher partout			for (var i=0;i<layers.length;i++)			{				for (var j=0;j<layers[i].selectedProperties.length;j++)				{					var effet = Duik.utils.getItem(layers,i).selectedProperties[j];					if (effet.canSetExpression && effet.parentProperty.name != "Morpher")					{						effet.expression = "valueAtTime((thisComp.layer(\"" + layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";						//la boucle pour créer automatiquement des clefs sur le morpher :						if (Duik.settings.morpherCreatesKeyframes)						{							//nombre de clefs							var nbreClefs = effet.numKeys;							//durée d'image de la compo							var ips = app.project.activeItem.frameDuration;							var temps = 0;							var prop = effet;							for (var k=1;k<=nbreClefs;k++)							{                 								//récupère l'instant de la clef								temps = prop.keyTime(k);								//crée une image clef sur le morpher								morpher(1).setValueAtTime(temps,temps/ips);							}							delete temps;							delete prop;							delete ips;							delete nbreClefs;   						}					}				}			}			return true;		}	}	/* LENS FLARE - Duik.lensFlare(layers);			Rigs the layers to move like a lens flare.			parameters		layers | Array of AVLayer				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.lensFlare !== 'function')	{		Duik.lensFlare = function (layers)		{			//sortir le premier calque, le centre, et ajouter les contrôleurs			var centre = layers.shift();						//check names			Duik.utils.checkNames(centre.containingComp);						var nomcentre = centre.name;			var centerEffect;			if (Duik.usePresets) centerEffect = Duik.utils.addPseudoEffect(centre,"DUIK_LensFlare");			else centerEffect = centre.effect.addProperty("DUIK_LensFlare");			centerEffect.name = Duik.uiStrings.lensFlare;			centerEffect(1).setValue(100);			centerEffect(2).setValue(100);						//l'expression de position			var positionexpression = "//Duik.LensFlare\r\n" + 			"calqueCentre = thisComp.layer(\"" + nomcentre + "\");\n\n" +			"function positionAbs(calque) {\n" +			"return calque.toWorld(calque.anchorPoint)\n" +			"}\n\n" +			"n=effect(\"" + centerEffect.name + "\")(1);\n\n" +			"X = thisComp.width - positionAbs(calqueCentre)[0];\n" +			"Y = thisComp.height - positionAbs(calqueCentre)[1];\n\n" +			"i=n/100;\n" +			"j=1-i;\n\n" +			"if (n!=100) value + ( (  [X,Y]*(i/j) + positionAbs(calqueCentre) )*j)\n" + 			"else value + [X,Y];";			//l'expression d'opacité			var opaciteexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + centre.name  + "\").effect(\"" + centerEffect.name + "\")(1);\n" + "value*n/100";						//l'expression d'échelle			var tailleexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + nomcentre  + "\").effect(\"" + centerEffect.name + "\")(2);\n" + "value*n/100";						//appliquer les expressions sur le centre			centre.transform.opacity.expression = opaciteexpression;			centre.transform.scale.expression = tailleexpression;			//la boucle d'application des expressions et contrôleurs			var nombrecalques = layers.length;			for (var layerI = 0; layerI < nombrecalques; layerI++)			{				calque = layers[layerI];				calque.position.setValue([0,0]);				//le controleur de la distance				var distanceEffect;				if (Duik.usePresets) distanceEffect = Duik.utils.addPseudoEffect(calque,"DUIK_LensFlareDistance");				else distanceEffect = calque.effect.addProperty("DUIK_LensFlareDistance");				distanceEffect.name = Duik.uiStrings.lensFlare;				distanceEffect(1).setValue(100/nombrecalques*(layerI+1));								//appliquer les expressions				calque.transform.position.expression = positionexpression;				calque.transform.opacity.expression = opaciteexpression;				calque.transform.scale.expression = tailleexpression;								//fin de la boucle			}						//sélectionner le centre (controleur)			Duik.utils.deselectLayers();			centre.selected = true;		}	}	/* DISTANCE LINK - Duik.distanceLink(layer,property,parentLayer);			Links the property to the distance of parentLayer			parameters		layer | AVLayer containing the property		property | Property to rig		parentLayer | AVLayer which distance from layer is used to rig				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.distanceLink !== 'function')	{		Duik.distanceLink = function (layer,prop,parentLayer)		{			//add effect			var effect = Duik.utils.rigProperty(layer,prop,"DUIK_DistanceLink");			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.distanceLink;			//get the distance between the two layers			var distance = Duik.utils.getDistance(layer,parentLayer);			effect(2).setValue(distance - distance/4.0);			effect(3).setValue(distance + distance/4.0);						//check names			Duik.utils.checkNames(layer.containingComp);						if (parentLayer instanceof CameraLayer)			{				prop.expression = "//Duik.DistanceLink\r\n" + 					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 					"falloff=effect(\"" + effect.name + "\")(6);\n" + 					"function positionAbs(calque) {\n" + 					"return calque.toWorld(calque.anchorPoint);\n" + 					"}\n\n" + 					"distance = length(calqueRef.position,positionAbs(thisLayer));\n" + 					"if (distMax>=distMin && falloff!=0){\n" + 					"if (distance <= distMax && distance >=distMin) {value}\n" + 					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 					"if (distMax==0){value + distance/falloff}\n" + 					"}else {value}";			}			else			{				prop.expression = "//Duik.DistanceLink\r\n" + 					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 					"falloff=effect(\"" + effect.name + "\")(6);\n" + 					"function positionAbs(calque) {\n" + 					"return calque.toWorld(calque.anchorPoint);\n" + 					"}\n\n" + 					"distance = length(positionAbs(calqueRef),positionAbs(thisLayer));\n" + 					"if (distMax>=distMin && falloff!=0){\n" + 					"if (distance <= distMax && distance >=distMin) {value}\n" + 					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 					"if (distMax==0){value + distance/falloff}\n" + 					"}else {value}";			}						return true;					}	}	/* SPRING - Duik.spring(property, layer, simulated);			Adds a spring effect on the property			parameters		property | Array of property		layer | AVLayer containing the property		simulated | if true, applies the simulated version of the spring, default: false				returns		true if successful, false if anything went wrong		*/	if (typeof Duik.spring !== 'function')	{		Duik.spring = function (prop, layer, simulated)		{			//search for one dimension effects, to know if we need a "bounce" checkbox			var bounce = false;			if (prop.propertyValueType == PropertyValueType.OneD) bounce = true;						//if it's not a position, light version			if (prop.matchName != "ADBE Position") simulated = false;			if (simulated == undefined) simulated = false;			var effect;			if (bounce)			{				effect = Duik.utils.rigProperty(layer,prop,"DUIK_Spring_Bounce");			}			else			{				effect = Duik.utils.rigProperty(layer,prop,"DUIK_Spring");			}			if (effect == null) return false;			effect.name = prop.name + " " + Duik.uiStrings.spring;						if (bounce)			{				prop.expression = "//Duik.Spring\r\n" + 							"amorti = effect(\"" + effect.name + "\")(2);\n" + 							"freq = effect(\"" + effect.name + "\")(1);\n\n" + 							"rebond = effect(\"" + effect.name + "\")(3);\n\n" + 							"if (numKeys > 1 && freq != 0 ){\n" + 							"if (nearestKey(time).index == 1) { value }\n" + 							"else {\n\n" + 							"if (length(velocity) == 0) {\n\n" + 							"tempsClefProx = nearestKey(time).time;\n\n" + 							"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" + 							"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" + 							"temps = time - tempsDebut;\n\n" + 							"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n\n" + 							"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" + 							"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" + 							"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" + 							"}\n" + 							"else { value }\n" + 							"}\n" + 							"}\n" + 							"else { value }";			}			else if (!simulated)			{				prop.expression = "//Duik.Spring\r\n" + 								"amorti = effect(\"" + effect.name + "\")(2);\n" + 								"freq = effect(\"" + effect.name + "\")(1);\n\n" + 								"rebond = 0;\n\n" + 								"if (numKeys > 1 && freq != 0 ){\n" + 								"if (nearestKey(time).index == 1) { value }\n" + 								"else {\n\n" + 								"if (length(velocity) == 0) {\n\n" + 								"tempsClefProx = nearestKey(time).time;\n\n" + 								"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" + 								"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" + 								"temps = time - tempsDebut;\n\n" + 								"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n\n" + 								"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" + 								"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" + 								"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" + 								"}\n" + 								"else { value }\n" + 								"}\n" + 								"}\n" + 								"else { value }";			}			else			{				prop.expression = "//Duik.spring\r\n" +							"amorti = effect(\"" + effect.name + "\")(2);\n" + 							"freq = effect(\"" + effect.name + "\")(1);\n" + 							"if (amorti == 0) amorti = 0.1;\n" + 							"if (freq == 0) freq = 0.1;\n" + 							"retard = freq/amorti;\n" + 							"poids = 1/amorti/10;\n" + 							"precision = thisComp.frameDuration;\n" + 							"function worldVelocity(temps) {\n" + 							"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" + 							"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" + 							"return [worldVelocityX,worldVelocityY];\n" + 							"}\n" + 							"function worldSpeed(temps) {\n" + 							"return length(worldVelocity(temps));\n" + 							"}\n" + 							"tempsDebut = 0;\n" + 							"tempsRedemarrage = 0;\n" + 							"stop = false;\n" + 							"arrete = false;\n" + 							"for (i=timeToFrames(time);i>=0;i--) {\n" + 							"var instant = framesToTime(i);\n" + 							"var instantSuivant = instant-precision;\n" + 							"if (worldSpeed(instant) == 0 ) {\n" + 							"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" + 							"if (worldSpeed(instantSuivant) !=0 ) {\n" + 							"tempsDebut = instantSuivant;\n" + 							"break;\n" + 							"}\n" + 							"}\n" + 							"}\n" + 							"temps = time-tempsDebut;\n" + 							"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" + 							"valeur = value\n" + 							"if ( frameRedemarre <= retard)\n" + 							"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" + 							"else\n" + 							"valeur = value - worldVelocity(time)*poids;\n" + 							"if (worldSpeed(time) == 0) {\n" + 							"spring = worldVelocity(tempsDebut) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" + 							"valeur + spring;\n" + 							"}else{ valeur; }\n";			}							return true;		}	}	// REPLACE IN EXPRESSIONS - Duik.utils.replaceInExpressions(prop,oldString,newString)	if (typeof Duik.replaceInExpressions !== 'function')	{		Duik.replaceInExpressions = function (prop,oldString,newString)		{			if (prop.propertyType == PropertyType.PROPERTY)			{				if (prop.canSetExpression)				{					var expr = prop.expression;					while (expr.indexOf(oldString) >= 0) expr = expr.replace(oldString,newString);					prop.expression = expr;					delete expr;				}			}			else if (prop.numProperties > 0)			{				for (var propertyIndex = 1;propertyIndex <= prop.numProperties;propertyIndex++)				{					replaceInExpressions(prop.property(propertyIndex),oldString,newString);				}			}		}				}	/* REPLACE IN LAYERS EXPRESSIONS - Duik.replaceInLayersExpressions(layers,oldString,newString);			Replaces all occurences of oldString by newString in all the expressions of all the layers.			parameters		layers | Array of AVLayers or LayerCollection		oldString | string		newString | string				returns		void		*/	if (typeof Duik.replaceInLayersExpressions !== 'function')	{		Duik.replaceInLayersExpressions = function (layers,oldString,newString)		{			for (var layerIndex = 0 ; layerIndex<layers.length ; layerIndex++)			{				var l = Duik.utils.getItem(layers,layerIndex);				var locked = l.locked;				l.locked = false;				//transform				Duik.replaceInExpressions(l.transform,oldString,newString);				//masks				if (l("masks") != null) Duik.replaceInExpressions(l("masks"),oldString,newString);				//effects				if (l("effects") != null) Duik.replaceInExpressions(l("effects"),oldString,newString);				l.locked = locked;				delete l;				delete locked;			}		}	}	/* PATH FOLLOW - Duik.pathFollow(layer);			Automates the rotation of the layer so it follows its path.			parameters		layer | AVLayer				returns		void		*/	if (typeof Duik.pathFollow !== 'function')	{		Duik.pathFollow = function (layer)		{			//expression a insérer			layer.transform.rotation.expression  = "ff = framesToTime(1);\r\n" + 			"pos = thisLayer.position;\r\n" + 			"if (pos.numKeys > 1){\n" + 			"A = pos.valueAtTime(time-ff);\r\n" + 			"B =  pos.valueAtTime(time+ff);\r\n\r\n" + 			"if (pos.key(1).time > time){\r\n" + 			"A = pos.key(1).value;\r\n" + 			"B =pos.valueAtTime(pos.key(1).time+ff);\r\n" + 			"}\r\n\r\n" + 			"if (thisLayer.position.key(thisLayer.position.numKeys).time < time){\r\n" + 			"A = pos.valueAtTime(pos.key(pos.numKeys).time-ff);\r\n" + 			"B = pos.key(pos.numKeys).value;\r\n" + 			"}\r\n\r\n" + 			"angle = lookAt(A,B);\r\n" + 			"angle[0] > 0 ? angle[0]+angle[1]+value : angle[0]-angle[1]+value;\r\n" +			"} else value;";		}	}	/* MULTIPLANE - Duik.multiplane(numLayers,position,scale);			Creates null objects rigged to easily animate a 2D multiplane camera.			parameters		numLayers | int, number of layers to create, default: 3		position | boolean, true to rig positions, default: true		scale | boolean, true to rig scales, default: false				returns		void		*/	if (typeof Duik.multiplane !== 'function')	{		Duik.multiplane = function (nbre,pos,sca)		{			if (nbre == undefined) nbre = 3;			if (pos == undefined) pos = true;			if (sca == undefined) sca = true;						//la couche caméra			camNbre = Math.ceil(nbre/2);			if (pos && !sca)			{				//créer un zéro				var zero = app.project.activeItem.layers.addNull();				zero.name = "Zero_multiplane";				//verrouiller et masquer le zéro				zero.moveToEnd();				zero.guideLayer = true;				zero.locked = true;				zero.shy = true;				zero.enabled = false;				for (var i=1;i<=nbre;i++)				{					var numero = "L00";					i < 10 ? numero = "L0" + i : numero = "L" + i ;					//créer les nuls et leurs zéros					var calque = app.project.activeItem.layers.addNull() ;					calque.parent = zero;					if (i == camNbre) 					{						calque.name = numero + " cam";					}					else					{						calque.name = numero;						calque.locked = true;					}					delete calque;				}							delete zero;				//ajouter les expressions et curseurs				for (var i=1;i<=nbre;i++)				{					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)					if (i != camNbre-nbre%2+1 )					{						var calque = app.project.activeItem.layer(i);						var curseur = calque.Effects.addProperty("ADBE Slider Control");						curseur.name = "influence position";						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;						delete curseur;						calque.transform.position.expression = "thisComp.layer(\"L0" + camNbre + " cam\").position * effect(\"influence position\")(1)";					}				}		   }			else if (!pos && sca)			{				//créer un zéro				var zero = app.project.activeItem.layers.addNull();				zero.name = "Zero_multiplan";				//verrouiller et masquer le zéro				zero.moveToEnd();				zero.guideLayer = true;				zero.locked = true;				zero.shy = true;				zero.enabled = false;				for (var i=1;i<=nbre;i++)				{					var numero = "L00";					i < 10 ? numero = "L0" + i : numero = "L" + i ;					//créer les nuls et leurs zéros					var calque = app.project.activeItem.layers.addNull() ;					calque.parent = zero;					if (i == camNbre) 					{						calque.name = numero + " cam";					}					else					{						calque.name = numero;						calque.locked = true;					}					delete calque;				}								delete zero;				//ajouter les expressions et curseurs				for (var i=1;i<=nbre;i++)				{					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)					if (i != camNbre-nbre%2+1 )					{						var calque = app.project.activeItem.layer(i);						var curseur = calque.Effects.addProperty("ADBE Slider Control");						curseur.name = "influence echelle";						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;						delete curseur;						calque.transform.scale.expression = "thisComp.layer(\"L0" + camNbre + " cam\").scale * effect(\"influence echelle\")(1) - [100,100]* effect(\"influence echelle\")(1) + [100,100]";					}				}			}			else if (pos && sca)			{				//créer un zéro				var zero = app.project.activeItem.layers.addNull();				zero.name = "Zero_multiplan";				//verrouiller et masquer le zéro				zero.moveToEnd();				zero.guideLayer = true;				zero.locked = true;				zero.shy = true;				zero.enabled = false;				for (var i=1;i<=nbre;i++)				{					var numero = "L00";					i < 10 ? numero = "L0" + i : numero = "L" + i ;					//créer les nuls et leurs zéros position					var calque = app.project.activeItem.layers.addNull() ;					calque.parent = zero;					if (i == camNbre) 					{						calque.name = numero + " cam position";					}					else					{						calque.name = numero;						calque.locked = true;					}					delete calque;				}				//ajouter les expressions et curseurs position				for (var i=1;i<=nbre;i++)				{					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)					if (i != camNbre-nbre%2+1 )					{						var calque = app.project.activeItem.layer(i);						var curseur = calque.Effects.addProperty("ADBE Slider Control");						curseur.name = "influence position";						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;						delete curseur;						calque.transform.position.expression = "thisComp.layer(\"L0" + camNbre + " cam position\").position * effect(\"influence position\")(1)";					}				}								for (var i=1;i<=nbre;i++)				{					var numero = "L00";					i < 10 ? numero = "L0" + i : numero = "L" + i ;					//créer les nuls et leurs zéros scale					var calque = app.project.activeItem.layers.addNull() ;					calque.parent = zero;					if (i == camNbre) 					{						calque.name = numero + " cam scale";					}					else					{						calque.name = numero;						calque.locked = true;					}					delete calque;				}								//ajouter les expressions et curseurs scale				for (var i=1;i<=nbre;i++)				{					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)					if (i != camNbre-nbre%2+1 )					{						var calque = app.project.activeItem.layer(i);						var curseur = calque.Effects.addProperty("ADBE Slider Control");						curseur.name = "influence echelle";						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;						delete curseur;						calque.transform.scale.expression = "thisComp.layer(\"L0" + camNbre + " cam scale\").scale * effect(\"influence echelle\")(1) - [100,100]* effect(\"influence echelle\")(1) + [100,100]";					}				}				delete zero;				//relinker les positions aux échelles				for (var i=1;i<=nbre;i++)				{					app.project.activeItem.layer(nbre + i).locked = false;					app.project.activeItem.layer(nbre + i).parent = app.project.activeItem.layer(i);					if (app.project.activeItem.layer(nbre + i).name.indexOf("cam") < 0) app.project.activeItem.layer(nbre + i).locked = true;				}			}		}	}	/* COPY ANIM - Duik.copyAnim(layers,selectedKeysOnly,startTime,endTime,);			Copy all the animations (except expressions) on selected layers, and store them in Duik.copiedAnim.			parameters		layers | Array or Collection of AVLayers		selectedKeysOnly | boolean, true to copy only selected keys, default: false		startTime | float, default: start of comp		endTime | float, default: end of comp				returns		Array of LayerAnim		*/	if (typeof Duik.copyAnim !== 'function')	{		Duik.copyAnim = function (layers,selectedKeysOnly,startTime,endTime)		{			if (layers.length == 0)			{				return null;			}									var comp = Duik.utils.getItem(layers,0).containingComp						if (selectedKeysOnly == undefined) selectedKeysOnly = false;			if (startTime == undefined) startTime = comp.workAreaStart;			if (endTime == undefined) endTime = comp.workAreaDuration + comp.workAreaStart;			Duik.copiedAnim = [];			//parcourir tous les calques à la recherche des anims à sauvegarder			for (var layerIndex = 0; layerIndex < layers.length ; layerIndex++)			{				var layerAnim = new LayerAnim();				var l = Duik.utils.getItem(layers,layerIndex);				layerAnim.name = l.name;				layerAnim.index = l.index;				// 1 - sauver l'anim des transformations				layerAnim.transformAnims = Duik.utils.getPropertyAnims(l.transform,selectedKeysOnly,startTime,endTime);				// 2 - les masques				for (var maskIndex=1;maskIndex<=l("Masks").numProperties;maskIndex++)				{					var maskAnim = new MaskAnim();					maskAnim.name = l("Masks")(maskIndex).name;					maskAnim.anims = Duik.utils.getPropertyAnims(l("Masks")(maskIndex),selectedKeysOnly,startTime,endTime);					if (maskAnim.anims.length >=1) layerAnim.masksAnims.push(maskAnim);				}				// 3 - les effets				for (var effectIndex=1;effectIndex<=l("Effects").numProperties;effectIndex++)				{					var effectAnim = new EffectAnim();					effectAnim.name = l("Effects")(effectIndex).name;					effectAnim.matchName = l("Effects")(effectIndex).matchName;					effectAnim.anims = Duik.utils.getPropertyAnims(l("Effects")(effectIndex),selectedKeysOnly,startTime,endTime);					if (effectAnim.anims.length >=1) layerAnim.effectsAnims.push(effectAnim);				}								Duik.copiedAnim.push(layerAnim);							}			return Duik.copiedAnim;		}	}	/* PASTE ANIM - Duik.pasteAnim(layers,layerAnims,startTime,useIndexes);	Paste all the animations in the Array of LayerAnim on layers, using layer names or layer indexes, beginning at startTime	parameters	layers | CompItem where to paste the animation	layerAnims | Array of LayerAnim, default: Duik.copiedAnim	startTime | float, default: comp.time	useIndexes | boolean, true to use layer indexes instead of their names, default: Duik.settings.pasteAnimUseIndexes		returns	integer, number of layers where animations were pasted		*/	if (typeof Duik.pasteAnim !== 'function')	{		Duik.pasteAnim = function (layers,layerAnims,startTime,useIndexes)		{			if (layerAnims == undefined) layerAnims = Duik.copiedAnim;			if (useIndexes == undefined) useIndexes = Duik.settings.pasteAnimUseIndexes;			var comp = Duik.utils.getItem(layers,0).containingComp;			if (startTime == undefined) startTime = comp.time;						var totalPasted = 0;						for (var li = 0;li < layers.length;li++)			{				var l = Duik.utils.getItem(layers,li);				var layerAnim = null;				//parcourir les animations sauvées pour trouver celle qui matche le calque				if (useIndexes)				{					for (var ai = 0;ai < layerAnims.length;ai++)					{						if (layerAnims[ai].index == l.index)						{							layerAnim = layerAnims[ai];							break;						}					}				}				else				{					for (var ai = 0; ai < layerAnims.length ; ai++)					{						if (layerAnims[ai].name == l.name)						{							layerAnim = layerAnims[ai];							break;						}					}				}								if (layerAnim == null) continue;								totalPasted++;				//transform				if (layerAnim.transformAnims.length > 0)				{					for (var j = 0;j< layerAnim.transformAnims.length; j++)					{						Duik.utils.setPropertyAnim(l.transform,layerAnim.transformAnims[j],startTime);					}				}								//masks				if (layerAnim.masksAnims.length > 0)				{					for (var j = 0;j< layerAnim.masksAnims.length; j++)					{						for (var k = 1;k<=l("Masks").numProperties;k++)						{							if (l("Masks")(k).name == layerAnim.masksAnims[j].name)							{								for (var mi = 0;mi < layerAnim.masksAnims[j].anims.length;mi++)								{									Duik.utils.setPropertyAnim(l("Masks")(layerAnim.masksAnims[j].name),layerAnim.masksAnims[j].anims[mi],startTime);								}								break;							}						}					}				}								//effects				if (layerAnim.effectsAnims.length > 0)				{					for (var j = 0;j< layerAnim.effectsAnims.length; j++)					{						for (var k = 1;k<=l("Effects").numProperties;k++)						{							if (l("Effects")(k).name == layerAnim.effectsAnims[j].name && l("Effects")(k).matchName == layerAnim.effectsAnims[j].matchName)							{								for (var ei = 0;ei < layerAnim.effectsAnims[j].anims.length;ei++)								{									Duik.utils.setPropertyAnim(l("Effects")(layerAnim.effectsAnims[j].name),layerAnim.effectsAnims[j].anims[ei],startTime);								}								break;							}						}					}				}			}			return totalPasted;		}	}}());