/*
Duik - Duduf IK Tools
Copyright (c) 2008 - 2015 Nicolas Dufresne
http://www.duduf.net

Many thanks to :
Eric Epstein - making the IK's work with 3D Layers

This file is part of Duik.

    Duik is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Duik is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Duik. If not, see <http://www.gnu.org/licenses/>.
*/

// =====================================================================
//                                   LibDuik 
// =====================================================================

/* This file should not be edited,

	If you need to change some settings, you should change them inside your own script.
	Example:
	Changing controllers size (in pixels):
		Duik.settings.controllerSize = 50;
		
	A complete list of settings is available in the developper's guide of libDuik on
	http://www.duduf.net
	
	If you need to change UI strings (for localization) you can access them in Duik.uiStrings
	Example:
		Duik.uiStrings.ikFkBox = "IK / FK"
		
	A complete list of uiStrings is available in the developper's guide of libDuik on
	http://www.duduf.net
	
	However, if you're modifying this file, you may want to force reload the class for testing purposes.
	After the definition block of Duik,change
		Duik.forceReload
	to true.
	
*/

if (typeof Duik !== 'object')
{
    Duik = {};
	Duik.version = "";
	Duik.versionNumber = 0;
}

Duik.forceReload = true;

//check if libDuik has been updated since first launch
if (Duik.versionNumber < 15.0005)
{
	Duik.version = "15.alpha5";
	Duik.versionNumber = 15.0005;
	Duik.forceReload = true;
	
	//--------- only if scripts are allowed to write files ------------
	//TODO Edit presetEffects.xml to add Duik Effects
	(function ()
	{
		
	}());
	//include presets (ffx) here
	//extract them to user folder (cf duik_images)
	(function ()
	{
		
	}());
	//----------------------------------------------------------
}

(function ()
{	
	//================================
	//           UI Strings
	//================================
	
	/* UI Strings
		Localisation
		
		TODO
		class Duik.uiStrings
		containing all needed uiString (localizable strings)
		
		Duik.setLanguage(lang)
		lang | string, language code
	*/
	if (typeof Duik.uiStrings !== 'object' || Duik.forceReload)
	{
		Duik.uiStrings = {};
		
		Duik.uiStrings.ik = "IK";
		Duik.uiStrings.wiggle = "Wiggle";
		Duik.uiStrings.exposure = "Exposure";
		Duik.uiStrings.rotMorph = "Rotation Morph";
		Duik.uiStrings.swing = "Swing";
		Duik.uiStrings.wheel = "Wheel";
		Duik.uiStrings.lensFlare = "Lens Flare";
		Duik.uiStrings.distanceLink = "Distance Link";
	}

	//================================
	//           SETTINGS
	//================================
	
	/* Duik Settings
	
	*/
	if (typeof Duik.settings !== 'object' || Duik.forceReload)
	{
		Duik.settings = {};
		
		Duik.sizes = {};
		Duik.sizes.SMALL = 0;
		Duik.sizes.MEDIUM = 1;
		Duik.sizes.BIG = 2;
		
		Duik.layerTypes = {};
		Duik.layerTypes.NULL = 1;
		Duik.layerTypes.SOLID = 0;
				
		if (! app.settings.haveSetting("duik", "boneType")){app.settings.saveSetting("duik","boneType",Duik.layerTypes.SOLID);}
		if (! app.settings.haveSetting("duik", "boneSize")){app.settings.saveSetting("duik","boneSize",20);}
		if (! app.settings.haveSetting("duik", "ctrlSize")){app.settings.saveSetting("duik","ctrlSize",100);}
		if (! app.settings.haveSetting("duik", "ctrlSizeAuto")){app.settings.saveSetting("duik","ctrlSizeAuto",true);}
		if (! app.settings.haveSetting("duik", "boneSizeAuto")){app.settings.saveSetting("duik","boneSizeAuto",true);}
		if (! app.settings.haveSetting("duik", "boneSizeAutoValue")){app.settings.saveSetting("duik","boneSizeAutoValue",Duik.sizes.MEDIUM);}
		if (! app.settings.haveSetting("duik", "ctrlSizeAutoValue")){app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.sizes.MEDIUM);}
		if (! app.settings.haveSetting("duik", "boneColor")){app.settings.saveSetting("duik","boneColor","FF0000");}
		if (! app.settings.haveSetting("duik", "morpherKeyframes")){app.settings.saveSetting("duik","morpherKeyframes",true);}
		
		Duik.settings.save = function ()
		{
			app.settings.saveSetting("duik","boneType",Duik.settings.boneType);
			app.settings.saveSetting("duik","boneSize",Duik.settings.boneSize);
			app.settings.saveSetting("duik","ctrlSize",Duik.settings.controllerSize);
			app.settings.saveSetting("duik","ctrlSizeAuto",Duik.settings.controllerSizeAuto);
			app.settings.saveSetting("duik","boneSizeAuto",Duik.settings.boneSizeAuto);
			app.settings.saveSetting("duik","boneSizeAutoValue",Duik.settings.boneSizeHint);
			app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.settings.controllerSizeHint);
			app.settings.saveSetting("duik","boneColor",Duik.settings.boneColor);
			app.settings.saveSetting("duik","morpherKey",Duik.settings.morpherCreatesKeyframes);
		}
		
		Duik.settings.load = function ()
		{
			Duik.settings.controllerSize = eval(app.settings.getSetting("duik","ctrlSize"));
			Duik.settings.controllerSizeAuto = eval(app.settings.getSetting("duik","ctrlSizeAuto"));
			Duik.settings.controllerSizeHint = eval(app.settings.getSetting("duik","ctrlSizeAutoValue"));
			Duik.settings.boneType = eval(app.settings.getSetting("duik","boneType"));
			Duik.settings.boneSize = eval(app.settings.getSetting("duik","boneSize"));
			Duik.settings.boneSizeAuto = eval(app.settings.getSetting("duik","boneSizeAuto"));
			Duik.settings.boneSizeHint = eval(app.settings.getSetting("duik","boneSizeAutoValue"));
			Duik.settings.boneColor = app.settings.getSetting("duik","boneColor");
			Duik.settings.morpherCreatesKeyframes = eval(app.settings.getSetting("duik","morpherKeyframes"));
		}
		
		Duik.settings.restoreDefaults = function ()
		{
			Duik.settings.controllerSize = 100;
			Duik.settings.controllerSizeAuto = true;
			Duik.settings.controllerSizeHint = Duik.sizes.MEDIUM;
			Duik.settings.boneType = Duik.layerTypes.SOLID;
			Duik.settings.boneSize = 20;
			Duik.settings.boneSizeAuto = true;
			Duik.settings.boneSizeHint = Duik.sizes.MEDIUM;
			Duik.settings.boneColor = "FF0000";
			Duik.settings.morpherCreatesKeyframes = true;
			
			Duik.settings.save();
		}
		
		Duik.settings.load();
	}
	
	//================================
	//           UTILS
	//================================
	
	if (typeof Duik.utils !== 'object' || Duik.forceReload)
	{
		Duik.utils = {};
		// RIG PROPERTY - Duik.utils.rigProperty(layer,prop,pseudoEffect)
		if (typeof Duik.utils.rigProperty !== 'function' || Duik.forceReload)
		{
			Duik.utils.rigProperty = function (layer,prop,pseudoEffect)
			{
				//if prop is an effect, need a way to recover it
				var isEffect,effetIndex,effetProfondeur,effetParentName;
				if (!Duik.utils.prepareProperty(prop,isEffect,effetIndex,effetProfondeur,effetParentName)) return null;
				
				//pseudo effect
				var effect = Duik.utils.addPseudoEffect(layer,pseudoEffect);
				if (isEffect){ prop = layer.effect(effetParentName)(effetIndex); }
				
				return effect;
			}
		}
		// PREPARE PROPERTY - Duik.utils.prepareProperty(prop,isFX,ind,prof,parentName,dimensions)
		if (typeof Duik.utils.prepareProperty !== 'function' || Duik.forceReload)
		{
			Duik.utils.prepareProperty = function (prop,isFX,ind,prof,parentName,dimensions)
			{
				if (!prop.canSetExpression) return false;
				isFX = false;
				if (prop.parentProperty.isEffect)
				{
					ind = prop.propertyIndex;
					prof = prop.propertyDepth;
					parentName = prop.parentProperty.name;
					isFX = true;
					dimensions = Duik.utils.getPropertyDimensions(prop);
				}
				return true;
			}
		}
		// GET DIMENSIONS - Duik.utils.getPropertyDimensions(property)
		if (typeof Duik.utils.getPropertyDimensions !== 'function' || Duik.forceReload)
		{
			Duik.utils.getPropertyDimensions = function (prop)
			{
				var dimensions = 1;
				if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
				{
					//if this is a position and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
					if (!prop.parentProperty.isEffect && prop.name.toLowerCase() == "position" && !app.project.activeItem.selectedLayers[0].threeDLayer)
					{
						dimensions = 2;
					}
					else
					{
						dimensions = 3;
					}
				}
				else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
				{
					dimensions = 2;
				}
				return dimensions;
			}
		}
		// GET LENGTH - Duik.utils.getLength(value1,value2)
		if (typeof Duik.utils.getLength !== 'function' || Duik.forceReload)
		{
			Duik.utils.getLength = function (value1,value2)
			{
				if (typeof value1 !== typeof value2)
				{
					return null;
				}
				if (value1.length > 0)
				{
					var result = 0;
					for (dim = 0;dim<value1.length;dim++)
					{
						result += (value1[dim]-value2[dim])*(value1[dim]-value2[dim]);
					}
					result = Math.sqrt(result);
					return result;
				}
				else return Math.abs(value1 - value2) ;
			}
		}
		// GET AVERAGE SPEED - Duik.utils.getAverageSpeed(layer,property)
		if (typeof Duik.utils.getAverageSpeed !== 'function' || Duik.forceReload)
		{
			Duik.utils.getAverageSpeed = function (layer,prop)
			{
				//for each frame of the comp
				var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;
				var lastTime = prop.keyTime(prop.numKeys);
				var firstTime = prop.keyTime(1);
				var lastFrame = lastTime/layer.containingComp.frameDuration ;
				var firstFrame = firstTime/layer.containingComp.frameDuration ;
				if (lastFrame > frames) lastFrames = frames;
				if (firstFrame < 1) firstFrame = 1;
				var sum = 0;
				for ( frame = firstFrame ; frame < lastFrame ; frame++)
				{
					var time = frame*app.project.activeItem.frameDuration;
					sum += Duik.utils.getLength(prop.valueAtTime(time,false),prop.valueAtTime(time-layer.containingComp.frameDuration,false));
				}
				return sum/(lastFrame-firstFrame);
			}
		}
		// ADD PSEUDO EFFECT - Duik.utils.addPseudoEffect(layer,pseudoEffectName)
		if (typeof Duik.utils.addPseudoEffect !== 'function' || Duik.forceReload)
		{
			Duik.utils.addPseudoEffect = function (layer,preset)
			{
				//applyPreset is bugged and always applies presets on selected layers instead of the given one,
				//first deselect everything and select the wanted layer
				var selection = app.project.activeItem.selectedLayers;
				Duik.utils.deselectLayers();
				layer.selected = true;
				
				
				var thisFile = $.fileName;
				var presetFile = new File(thisFile.substring(0,thisFile.lastIndexOf("/")) + "/" + preset);
				layer.applyPreset(presetFile);
				
				var newEffect = null;
				
				for (fx = 1;fx <= layer("Effects").numProperties;fx++)
				{
					if (layer.effect(fx).name == preset.substring(5,preset.lastIndexOf(".")) )
					{
						newEffect = layer.effect(fx);
						break;
					}
				}
				
				//restore selection...
				layer.selected = false;
				for (selectedLayerIndex=0;selectedLayerIndex<selection.length;selectedLayerIndex++)
				{
					selection[selectedLayerIndex].selected = true;
				}
				
				return newEffect;
			}
		}
		// GET ALL PUPPET PINS FROM A LAYER - Duik.utils.getPuppetPins(prop)
		if (typeof Duik.utils.getPuppetPins !== 'function' || Duik.forceReload)
		{
			Duik.utils.getPuppetPins = function (prop) {
				var coins = [];
				if (prop != null)
				{
					if (prop.matchName == "ADBE FreePin3 PosPin Atom")
					{
						coins.push(prop);
					}
					else if (prop.numProperties > 0)
					{
						//contournement de bug...
						//d'abord recup les propriétés dans un tableau avant de les parcourir
						//sinon l'incrément fonctionne pas dans la boucle, allez savoir pourquoi

						var proprietes = [];
						for (p=1;p<=prop.numProperties;p++)
						{
							proprietes.push(prop.property(p));
						}

						for (pi in proprietes)
						{
							var newCoins = Duik.utils.getPuppetPins(proprietes[pi]);
							if (newCoins.length > 0)
							{
								coins = coins.concat(newCoins);
							}
						}
					}
				}
				
				return coins;
			}
		}
		// MEASURE DISTANCE BETWEEN TWO LAYERS - Duik.utils.getDistance(layer1,layer2)
		if (typeof Duik.utils.getDistance !== 'function' || Duik.forceReload)
		{
			Duik.utils.getDistance = function (layer1,layer2)
			{
				//parents
				var layer1Parent = layer1.parent;
				var layer2Parent = layer2.parent;	
				//unlink
				layer1.parent = null;
				layer2.parent = null;
				var O = layer1.transform.position.value;
				var A = layer2.transform.position.value;
				var OA = Duik.utils.getLength(O,A);
				//re-link
				layer1.parent = layer1Parent;
				layer2.parent = layer2Parent;
				return Math.round(OA);
			}
		}
		// DESELECT ALL LAYERS - Duik.utils.deselectLayers()
		if (typeof Duik.utils.deselectLayers !== 'function' || Duik.forceReload)
		{
			Duik.utils.deselectLayers = function ()
			{
				var sel = app.project.activeItem.selectedLayers;
				for (selectedLayerIndex=0;selectedLayerIndex<sel.length;selectedLayerIndex++)
				{
					sel[selectedLayerIndex].selected = false;
				}
			}
		}
	}
	
	//================================
	//           METHODS
	//================================
	
	//TODO, instead of returning true or false, functions should return the effect created
	
	/*	ADD IK - Duik.IK(controller,layer1,layer2,layer3,goal,clockWise,threeD,frontFacing)
		adds a 2D IK to the layers controlled by controller
		
		parameters:
		controller | AVLayer
		layer1 | AVLayer
		layer2 | AVLayer or undefined
		layer3 | AVLayer or undefined
		goal | AVLayer or undefined
		clockWise | boolean, used only with two-layer and three-layer IK, default: false
		threeD | boolean, works only with two-layer IK, default: false
		frontFacing | boolean, default: false
				
		returns
		true if successful, false if anything went wrong
	*/
	if (typeof Duik.IK !== 'function' || Duik.forceReload)
	{
		Duik.IK = function (ctrl,layer1,layer2,layer3,goal,cw,threeD,frontFacing)
		{	
			//if there's not at least one controller and one layer, abort creation
			if (ctrl == undefined || layer1 == undefined) return false;
			
			if (cw == undefined) cw = false;
			if (threeD == undefined) threeD = false;
			if (frontFacing == undefined) frontFacing = false;
			
			var zero = null;
			
			if (layer2 == undefined && layer3 == undefined)
			{
				var ok = Duik.oneLayerIK(ctrl,layer1);
				if (!ok) return false;
				if (goal != undefined)
				{
					var ok = Duik.addGoal(goal,ctrl);
					return ok;
				}
			}
			else if (layer3 == undefined)
			{
				zero = Duik.twoLayerIK(threeD,ctrl,layer1,layer2,cw);
				if (zero == null) return false;
			}
			else
			{
				threeD = false;
				var zero = Duik.threeLayerIK(ctrl,layer1,layer2,layer3,cw);
				if (zero == null) return false;
			}
			
			if (zero != null && goal != undefined)
			{
				var ok = Duik.goal(goal,ctrl);
				if (!ok) return false;

				//link the position in case of stretch
				goal.transform.position.expression = "thisComp.layer(\"" + zero.name + "\").transform.position;";
				
			}
				
			return true;
		}
	}
	// ADD ONE-LAYER IK - Duik.oneLayerIK(controller,layer)
	if (typeof Duik.oneLayerIK !== 'function' || Duik.forceReload)
	{
		Duik.oneLayerIK = function (ctrl,layer1)
		{
			//if there's not at least one controller and one layer, abort creation
			if (ctrl == undefined || layer1 == undefined) return false;
					
			var controllerName = ctrl.name;
			
			//pseudo effect
			var effect = Duik.utils.addPseudoEffect(ctrl,"Duik_1ik.ffx");
			effect.name = Duik.uiStrings.ik + " "  + layer1.name;
						
			//rotation d'origine
			var orot = layer1.transform.rotation.value;

			//=========================================================
			//EXPRESSION TO INSERT
			var expression = "//Duik.oneLayerIK\r\n" + 
			"CName = \"" + controllerName + "\";\r\n" +
			"C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\r\n" +
			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\r\n" +
			"W = thisComp.layer(CName).effect(\"" + effect.name + "\")(1)/100;\r\n" + 
			"FK = thisComp.layer(CName).effect(\"" + effect.name + "\")(3);\r\n" +
			"R = thisComp.layer(CName).effect(\"" + effect.name + "\")(2);\r\n" + 
			"angle = lookAt(C,O);\r\n" +
			"angle = angle*W;\r\n" +
			"R == 1 ? angle = -angle : angle;\r\n" +
			"var result;\r\n" +
			"angle[0] > 0 ? result = angle[0]+angle[1]+FK+value : result = angle[0]-angle[1]+FK+value;\r\n" +
			"var layer = thisLayer;\r\n" +
			"while (layer.hasParent)\r\n" +
			"{\r\n" +
			"layer = layer.parent;\r\n" +
			"result = result - layer.rotation;\r\n" +
			"}\r\n" +
			"result;";
			//=========================================================

			layer1.transform.rotation.expression = expression;
			
			//nouvelle rotation
			var nrot = layer1.transform.rotation.value;

			layer1.transform.rotation.setValue(-nrot+2*orot);
			
			//select controller
			Duik.utils.deselectLayers();
			ctrl.selected = true;
			
			return true;
		}
	}
	// ADD TWO-LAYER IK - Duik.twoLayerIK(threeD,controller,root,end,clockWise,frontFacing)
	if (typeof Duik.twoLayerIK !== 'function' || Duik.forceReload)
	{
		Duik.twoLayerIK = function (threeD,controller,root,end,clockWise,frontFacing)
		{
			//if there's not at least one controller and two layers, abort creation
			if (controller == undefined || root == undefined || end == undefined) return false;
			
			if (clockWise == undefined) clockWise = false;
			if (frontFacing == undefined) frontFacing = false;
			
			//Names
			var endName = end.name;
			var rootName = root.name;
			var controllerName = controller.name;
			
			//pseudo effect
			var effect = Duik.utils.addPseudoEffect(controller,"Duik_2ik.ffx");
			effect.name = Duik.uiStrings.ik + " "  + endName;
			if (clockWise) effect(1).setValue(1);

			if (threeD) {
				direction = controller.Effects.addProperty("ADBE Angle Control");
				direction.name = "IK Direction " +  rootName.slice(-15);
			}
					
			//créer un zéro
			endZero = app.project.activeItem.layers.addNull();
			endZero.threeDLayer = true;
			var controllerParent = controller.parent;
			controller.parent = null;
			endZero.position.setValue(controller.position.value);
			endZero.name = "IK_zero " + endName.slice(-24);
			controller.parent = controllerParent;
	
			//lier le zéro au bone du bout
			endZero.parent = end;

			//verrouiller et masquer le zéro
			endZero.moveToEnd();
			endZero.guideLayer = true;
			endZero.locked = true;
			endZero.enabled = false;
			endZero.shy = true;

			endZeroName = endZero.name;

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			var endExpression = "//Duik.twoLayerIK\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"bonebout = \"" + endName + "\";\n" + 
				"zero = \"" + endZeroName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" +
				"FK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(5);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +
				"if (thisComp.layer(controleur).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" +
				"function getWorldPos(theLayerName){\n" + 
				"  L = thisComp.layer(theLayerName);\n" + 
				"  return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"function oriente(a, b, P) {\n" +
				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +
				"}\n" +
				"A = getWorldPos(boneracine);\n" + 
				"B = getWorldPos(bonebout);\n" + 
				"C = getWorldPos(zero);\n" + 
				"E = getWorldPos(controleur);\n" + 
				"a = length(B,C);\n" + 
				"b = length(E,A);\n" + 
				"c = length(A,B);\n" + 
				"x = (b*b + c*c - a*a )/(2*b);\n" + 
				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 
				"y = b - x;\n" + 
				"  gamma = Math.acos(clamp(y/a,-1,1));\n" + 
				"result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);" +
				"  V1 = B - A;\n" + 
				"  adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n" + 
				"  V2 = C - B;\n" + 
				"  adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n" + 
				"  IK = result +  adj1 - adj2 + value;\n" + 
				"IKFK ? IK : FK;";
			//=========================================================

			threeD ? end.transform.zRotation.expression = endExpression : end.transform.rotation.expression = endExpression;

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE RACINE
			var rootExpression = "//Duik.twoLayerIK\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"bonebout = \"" + endName + "\";\n" + 
				"zero = \"" + endZeroName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" +
				"FK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(4);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +
				"if (thisComp.layer(controleur).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" +
				"function getWorldPos(theLayerName){\n" + 
				"  L = thisComp.layer(theLayerName);\n" + 
				"  return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"function oriente(a, b, P) {\n" +
				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +
				"}\n" +
				"A = getWorldPos(boneracine);\n" + 
				"B = getWorldPos(bonebout);\n" + 
				"C = getWorldPos(zero);\n" + 
				"E = getWorldPos(controleur);\n" + 
				"a = length(B,C);\n" + 
				"b = length(E,A);\n" + 
				"c = length(A,B);\n" + 
				"x = (b*b + c*c - a*a )/(2*b);\n" + 
				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 
				"D = E - A;\n" + 
				"delta = Math.atan2(D[1],D[0]);\n" + 
				"result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n" +
				"V = B - A;\n" + 
				"adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n" + 
				"IK = result - adj1 + value;\n" + 
				"IKFK ? IK : FK;";
			//=======================================================

			threeD ? root.transform.zRotation.expression = rootExpression : root.transform.rotation.expression = rootExpression;

			if (threeD) {
				//si 3D : le zéro de la jambe pour l'orientation
				//créer un zéro
				var zero = app.project.activeItem.layers.addNull();
				zero.threeDLayer = true;
				var calqueparent = root.parent;
				root.parent = null;
				zero.position.setValue(root.position.value);
				zero.name = "Zero_" + rootName.slice(-24);
				//verrouiller et masquer le zéro
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.shy = true;

				if (frontFacing) {
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"Cx = C[0];\n" +
						"Cy = C[1];\n" +
						"Cz = C[2];\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"Lx = L[0];\n" +
						"Ly = L[1];\n" +
						"Lz = L[2];" +
						"angle = lookAt([Cz,Cy,Cx],[Lz,Ly,Lx]);\n" +
						"[-angle[1]+90,-angle[0],value[2]]\n"
				} else { //front
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"angle = lookAt(C,L);\n" +
						"[angle[0],angle[1],value[2]]\n"
				} //else front
				zero.transform.orientation.expression = zeroExpression;
				zero.transform.xRotation.expression = "//Duik.twoLayerIK.threeD\r\n" + "thisComp.layer(\"" + controllerName + "\").effect(\"IK Direction " +  rootName.slice(-15) + "\")(1)";

				root.parent = zero;
				//lier le zéro au bone du bout
				zero.parent = calqueparent;
				zero.enabled = false;
				zero.locked = true;
			} //tridi

			//les expressions de stretch
			//les positions d'origine
			var posbout = end.transform.position.value.toString();
			var poszero = endZero.transform.position.value.toString();
			var apracine = root.transform.anchorPoint.value.toString();
			var apbout = end.transform.anchorPoint.value.toString();

			var expressionstretchbout = "//Duik.twoLayerIK.stretch\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" + 
				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(9)/2;\n" + 
				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(8);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +
				"function getWorldPos(theLayerName){\n" + 
				"L = thisComp.layer(theLayerName);\n" + 
				"return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 
				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 
				"proportion = dist1/(dist1+dist2);\n" + 
				"posC = getWorldPos(controleur);\n" + 
				"posR = getWorldPos(boneracine);\n" + 
				"distC = length(posC,posR);\n" + 
				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 
				"else stretch = stretch*proportion;\n" + 
				"coef = 1;\n" + 
				"dist1 != 0 ? coef = (dist1+stretch)/dist1 : coef = 1;\n" +
				"([" + posbout + "]-[" + apracine + "])*coef+[" + apracine + "];";

			end.transform.position.expression = expressionstretchbout;

			var expressionstretchzero = "//Duik.twoLayerIK.stretch\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" + 
				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(9)/2;\n" + 
				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effect.name + "\")(8);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" +
				"function getWorldPos(theLayerName){\n" + 
				"L = thisComp.layer(theLayerName);\n" + 
				"return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 
				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 
				"proportion = dist2/(dist1+dist2);\n" + 
				"posC = getWorldPos(controleur);\n" + 
				"posR = getWorldPos(boneracine);\n" + 
				"distC = length(posC,posR);\n" + 
				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 
				"else stretch = stretch*proportion;\n" + 
				"coef = 1;\n" + 
				"dist2 != 0 ? coef = (dist2+stretch)/dist2 : coef = 1;\n" +
				"([" + poszero + "]-[" + apbout + "])*coef+[" + apbout + "];";

			endZero.transform.position.expression = expressionstretchzero;
			
			//select controller
			Duik.utils.deselectLayers();
			controller.selected = true;
			
			return endZero;
		}
	}
	/* ADD GOAL - Duik.goal(layer,controller)
		adds a goal to the layer which may be controlled by a controller
		
		parameters:
		layer	| AVLayer
		controller | AVLayer or undefined
			
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.goal !== 'function' || Duik.forceReload)
	{
		Duik.goal = function (layer,controller)
		{
			//pour ne pas bouger, il faut récupérer la rotation d'origine
			var ancienneRot = 0;
			if (layer.threeDLayer) ancienneRot = layer.transform.zRotation.value;
			else ancienneRot = layer.transform.rotation.value;

			//si on a un controleur
			if (controller != undefined)
			{
				//ajouter la case sur le controleur
				var effetGoal = controller.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal" + " " + layer.name;
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				expr = "//Duik.goal\r\n" +
					"var C = thisComp.layer('" + controller.name + "');\r\n" + 
					"var goal = C.effect('" + effetGoal.name + "')(1);\r\n" + 
					"var result = value + C.rotation;\r\n" + 
					"if (goal == 1)\r\n" + 
					"{\r\n" + 
					"var layer = thisLayer;\r\n" + 
					"while (layer.hasParent)\r\n" + 
					"{\r\n" + 
					"layer = layer.parent;\r\n" + 
					"result = result - layer.rotation;\r\n" + 
					"}\r\n" + 
					"}\r\n" + 
					"result;";
		
				if (layer.threeDLayer) layer.transform.zRotation.expression = expr;
				else layer.transform.rotation.expression = expr;
			}
			else
			{
				//ajouter la case sur le calque
				var effetGoal = layer.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal";
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				layer.transform.rotation.expression = "//Duik.goal\r\n" +
					"var goal = thisLayer.effect('" + effetGoal.name + "')(1);\r\n" + 
					"var result = value;\r\n" + 
					"if (goal == 1)\r\n" + 
					"{\r\n" + 
					"var layer = thisLayer;\r\n" + 
					"while (layer.hasParent)\r\n" + 
					"{\r\n" + 
					"layer = layer.parent;\r\n" + 
					"result = result - layer.rotation;\r\n" + 
					"}\r\n" + 
					"}\r\n" + 
					"result;";
			}
	
			//et remettre la bonne rotation pour pas bouger
			var nouvelleRot = 0;
			if (layer.threeDLayer) nouvelleRot = layer.transform.zRotation.value;
			else nouvelleRot = layer.transform.rotation.value;

			if (layer.threeDLayer) layer.transform.zRotation.setValue(2*ancienneRot-nouvelleRot);
			else layer.transform.rotation.setValue(2*ancienneRot-nouvelleRot);
			
			//select controller
			if (controller != undefined)
			{
				Duik.utils.deselectLayers();
				controller.selected = true;
			}
			
			return true;
		}
	}
	/* ADD CONTROLLER - Duik.addController(layer)
	
		parameters
		layer | AVLayer
		
		returns
		AVLayer controller
	*/
	if (typeof Duik.addController !== 'function' || Duik.forceReload)
	{
		Duik.addController = function (layer)
		{
			var layerParent = layer.parent;
			layer.parent = null;
			var layerPosition = layer.transform.position.value;
			layer.parent = layerParent;

			//le controleur
			var controller = app.project.activeItem.layers.addNull();
			var controllerSize = Duik.settings.controllerSize;
			if (Duik.settings.controllerSizeAuto) {
				controllerSize = app.project.activeItem.width/2 + app.project.activeItem.height/2;
				if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40);
				else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20);
				else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10);
			}
			controller.source.width = controllerSize;
			controller.source.height = controllerSize;
			controller.anchorPoint.setValue([controller.source.width/2,controller.source.height/2]);
			controller.transform.position.setValue(layerPosition);
			controller.name = "C_" + layer.name.slice(-28);
			
			//select controller
			Duik.utils.deselectLayers();
			controller.selected = true;

			return controller;
		}
	}
	/* ADD CONTROLLERS - Duik.addControllers(layers)
		
		parameters
		layers | Array of AVLayer
		
		returns
		true if successful, false if anything went wrong
	*/
	if (typeof Duik.addControllers !== 'function' || Duik.forceReload)
	{
		Duik.addControllers = function (layers)
		{
			var controllers = [];
			
			for (i = 0 ; i < layers.length ; i++)
			{
				controllers.push(Duik.addController(layers[i]));
			}

			//select controllers
			Duik.utils.deselectLayers();
			for (controllerI = 0; controllerI < controllers.length;controllerI++)
			{
				controllers[controllerI].selected = true;
			}
			
			return controllers;
		}
	}
	/* ADD WIGGLE - Duik.wiggle(layer,property,separateDimensions)

		Adds a wiggle effect on the property of the layer
	
		parameters
		layer | AVLayer
		property | Property
		separateDimensions | boolean, default: false
		
		returns
		true if successful, false if anything went wrong
	*/
	if (typeof Duik.wiggle !== 'function' || Duik.forceReload)
	{
		Duik.wiggle = function (layer,prop,separateDimensions)
		{
			if (!prop.canSetExpression) return false;
			
			if (separateDimensions == undefined) separateDimensions = false;
			
			//dimensions
			var dimensions = Duik.utils.getPropertyDimensions(prop);
			if (!separateDimensions) dimensions = 1;
			
			var ok = false;
			
			if (dimensions == 3) ok = Duik.threeDWiggle(layer,prop);
			else if (dimensions == 2) ok = Duik.twoDWiggle(layer,prop);
			else ok = Duik.oneDWiggle(layer,prop);
			
			return ok;
		}
	}
	// ADD 3D WIGGLE - Duik.threeDWiggle(layer,property,x,y,z)
	if (typeof Duik.threeDWiggle !== 'function' || Duik.forceReload)
	{
		Duik.threeDWiggle = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_3dwiggle.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			
			prop.expression = "//Duik.3DWiggle\r\nX=wiggle(effect(\"" + effect.name + "\")(7),effect(\"" + effect.name + "\")(2));\n" + "Y=wiggle(effect(\"" + effect.name + "\")(8),effect(\"" + effect.name + "\")(3));\n" + "Z=wiggle(effect(\"" + effect.name + "\")(9),effect(\"" + effect.name + "\")(4));\n" +  "[X[0],Y[1],Z[2]]";
		
			return true;
		}
	}
	// ADD 2D WIGGLE - Duik.twoDWiggle(layer,property)
	if (typeof Duik.twoDWiggle !== 'function' || Duik.forceReload)
	{
		Duik.twoDWiggle = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_2dwiggle.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			prop.expression = "//Duik.2DWiggle\r\nX=wiggle(effect(\"" + effect.name + "\")(6),effect(\"" + effect.name + "\")(2));\n" + "Y=wiggle(effect(\"" + effect.name + "\")(7),effect(\"" + effect.name + "\")(3));\n" +  "[X[0],Y[1]]";
			
			return true;
		}
	}
	// ADD 1D WIGGLE - Duik.1DWiggle(layer,property)
	if (typeof Duik.oneDWiggle !== 'function' || Duik.forceReload)
	{
		Duik.oneDWiggle = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_1dwiggle.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			
			prop.expression = "//Duik.1DWiggle\r\nwiggle(effect(\"" + effect.name + "\")(2),effect(\"" + effect.name + "\")(1))";
			
			return true;

		}
	}
	/* EXPOSURE - Duik.exposure(layer,property,adaptative,limit,minExp,maxExp);
	
		Adds exposure controls to the animation of the property
	
		parameters
		layer | AVLayer
		property | Property
		adaptative | boolean, default: true
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.exposure !== 'function' || Duik.forceReload)
	{
		Duik.exposure = function (layer,prop,adaptative,limit,minExp,maxExp)
		{
			if (adaptative == undefined) adaptative = true;
			
			var ok = false;
			
			if (adaptative) ok = Duik.adaptativeExposure(layer,prop,limit,minExp,maxExp);
			else ok = Duik.fixedExposure(layer,prop);
			
			return ok;
		}
	}
	// ADAPTATIVE EXPOSURE - Duik.adaptativeExposure(layer,property,precision,minExp,maxExp);
	if (typeof Duik.adaptativeExposure !== 'function' || Duik.forceReload)
	{
		Duik.adaptativeExposure = function (layer,prop,limit,minExp,maxExp)
		{
			if (!prop.canSetExpression) return false;
			
			if (minExp == undefined) minExp = 1;
			if (maxExp == undefined) maxExp = 4;
			
			if (minExp <= 0) minExp = 1;
			if (maxExp <= 0) maxExp = 1;
			
			if (limit == undefined) limit = 100;
			if (limit == 0) limit = 1;
			
			limit = 1/limit*10000;		
			
			//for each frame of the comp
			var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;
			for ( frame = 0 ; frame < frames ; frame += minExp)
			{
				var time = frame*app.project.activeItem.frameDuration;
				var nearKey = prop.nearestKeyIndex(time);
				var nearKeyTime = prop.keyTime(nearKey);
					
				if (time <= nearKeyTime && nearKey == 1) continue;
				
				//get the value of the previous key
				var prevKey = 0;
				if (time < nearKeyTime) prevKey = nearKey -1;
				else prevKey = nearKey;
				
				if (prevKey == prop.numKeys) break;    
				
				var prevKeyValue = prop.keyValue(prevKey);
				var prevKeyTime = prop.keyTime(prevKey);
				
				//set a new key
				var speed = Duik.utils.getLength(prop.valueAtTime(time,false),prop.keyValue(prevKey));

				var exposure = (time - prevKeyTime) / app.project.activeItem.frameDuration;
				
				if (speed >= limit || exposure >= maxExp) prop.addKey(time);
				
			}

			//all key interpolations to HOLD
			for (keyIndex = 1;keyIndex <= prop.numKeys;keyIndex++)
			{
				prop.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
				
			}
			
			return true;
		}
	}
	// ADAPTATIVE EXPOSURE - Duik.fixedExposure(layer,property);
	if (typeof Duik.fixedExposure !== 'function' || Duik.forceReload)
	{
		Duik.fixedExposure = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_exposure.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.exposure;
			effect(1).setValue(1);
			
			prop.expression = "expo = effect(\"" + effect.name + "\")(1);\n" +
			"expo == 0 ? expo = 1 : Math.abs(expo);\n" +
			"timef = timeToFrames(time);\n" +
			"valueAtTime(framesToTime( timef - timef%expo ))";
		}
	}
	/* ADD BONES - Duik.addBones(layers);
	
		Adds bones to the layers, only on selected pins if any, or else on all puppet pins found on those layers.
	
		parameters
		layers | Array of AVLayer
		
		returns
		Array of AVLayers, the bones created
	
	*/
	if (typeof Duik.addBones !== 'function' || Duik.forceReload)
	{
		Duik.addBones = function (layers)
		{
			var createdBones = [];
			if (layers.length == 0) { return createdBones; }
			
			for (i=0;i<layers.length;i++)
			{
				var calque = layers[i];
				// les propriétés sélectionnées
				var props = calque.selectedProperties;
				var coins = [];
				//lister les puppet pins
				if (props.length > 0)
				{
					for (j=0;j<props.length;j++)
					{
						if (props[j].matchName == "ADBE FreePin3 PosPin Atom") coins.push(props[j]);
					}
				}
				//si il n'y a pas de coins sélectionnés, on les prend tous
				if (coins.length == 0) coins = Duik.utils.getPuppetPins(calque("Effects"));
				if (coins.length == 0) { return createdBones; }
				
				for (j=0;j<coins.length;j++)
				{
					var coin = coins[j];
					//la position du coin
					var position = coin.position.value;
					//créer le bone
					var bone;
					//sa taille
					boneTaille = Duik.settings.boneSize;
					if (Duik.settings.boneSizeAuto) {
						boneTaille = app.project.activeItem.width/2 + app.project.activeItem.height/2;
						if (Duik.settings.boneSizeHint == Duik.sizes.SMALL) boneTaille = Math.floor(boneTaille/60);
						else if (Duik.settings.boneSizeHint == Duik.sizes.MEDIUM) boneTaille = Math.floor(boneTaille/40);
						else if (Duik.settings.boneSizeHint == Duik.sizes.BIG) boneTaille = Math.floor(boneTaille/20);
					}
					if (Duik.settings.boneType == Duik.layerTypes.NULL)
					{
						bone = app.project.activeItem.layers.addNull();
						bone.name = "B_" + coin.name;
						bone.source.width = boneTaille;
						bone.source.height = boneTaille;
						bone.transform.anchorPoint.setValue([bone.source.width/2,bone.source.height/2]);
					}
					else
					{
						var colorString = Duik.settings.boneColor;
						var red = parseInt(colorString.substr(0,2),16)/255.0;
						var green = parseInt(colorString.substr(2,2),16)/255.0;
						var blue = parseInt(colorString.substr(4,2),16)/255.0;
						bone = app.project.activeItem.layers.addSolid([red,green,blue],"B_" + coin.name,boneTaille,boneTaille,app.project.activeItem.pixelAspect);
					}
					createdBones.push(bone);
					//mettre le bone à la position du coin : utiliser une expression pour avoir la position en mode world du coin
					var filet = coin.propertyGroup().propertyGroup();
					var marionnette = filet.propertyGroup().propertyGroup().propertyGroup();
					if (calque instanceof ShapeLayer)
					{
						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").effect(\"" + marionnette.name + "\").arap.mesh(\"" + filet.name + "\").deform(\"" + coin.name + "\").position";
					}
					else
					{
						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").toWorld(thisComp.layer(\"" + calque.name + "\").effect(\"" + marionnette.name + "\").arap.mesh(\"" + filet.name + "\").deform(\"" + coin.name + "\").position)";
					}
					bone.position.setValue(bone.position.value);
					bone.position.expression = "";
					//nom du bone
					bone.name = "B_" + coin.name;
					bone.guideLayer = true;
					//mettre l'expression dans le coin
					if (calque instanceof ShapeLayer)
					{
						coin.position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint)";
					}
					else
					{
						coin.position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint);\nfromWorld(bonePos)";
					}
				}//for coins
			}//for layers
			
			
			
			return createdBones;
		}
	}
	/* ADD ZEROS - Duik.addZeros(layers);
	
		Adds a null object for each layer, at the same place and orientation,
		and then parents the layer to it, parenting the null object (the zero) to the former
		parent of the layer.
	
		parameters
		layers | Array of AVLayer
		
		returns
		Array of AVLayers, the zeros created
	
	*/
	if (typeof Duik.addZeros !== 'function' || Duik.forceReload)
	{
		Duik.addZeros = function (layers)
		{
			var zeros = [];
			for (i = 0 ; i < layers.length ; i++)
			{
				var calque = layers[i];
				//create null object
				var zero = app.project.activeItem.layers.addNull();
				var calqueparent = calque.parent;
				calque.parent = null;
				zero.position.setValue(calque.position.value);
				zero.rotation.setValue(calque.rotation.value);
				zero.name = "Zero_" + calque.name.slice(-24);
				calque.parent = zero;

				//parent
				zero.parent = calqueparent;

				//lock and hide
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.locked = true;
				zero.shy = true;
				zero.enabled = false;
				
				zeros.push(zeros);
			}
			return zeros;
		}
	}
	/* ROTATION MORPH - Duik.rotationMorph(layer,prop);
	
		Creates a rotation morph on the given property
	
		parameters
		layer | AVLayer
		prop | Property
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.rotationMorph !== 'function' || Duik.forceReload)
	{
		Duik.rotationMorph = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_rotmorph.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.rotMorph;
			
			prop.expression = "//Duik.rotationMorph\r\n" + 
								"if (numKeys > 1)\r\n" + 
								"{\r\n" + 
								"r = thisLayer.effect('" + effect.name + "')(1).transform.rotation;\r\n" + 
								"n = timeToFrames(key(numKeys).time);\r\n" + 
								"Min =  thisLayer.effect('" + effect.name + "')(2);\r\n" + 
								"Max = thisLayer.effect('" + effect.name + "')(3);\r\n" + 
								"div =  (Max - Min) / n;\r\n" + 
								"val = 0;\r\n" + 
								"if (div != 0) val = r/div - (Min/div);\r\n" + 
								"valueAtTime(framesToTime(val));\r\n" + 
								"} else value;";
			
			return true;
		}
	}
	/* SWING - Duik.swing(layer,prop);
	
		Creates a swing on the given property
	
		parameters
		layer | AVLayer
		prop | Property
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.swing !== 'function' || Duik.forceReload)
	{
		Duik.swing = function (layer,prop)
		{
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_swing.ffx");
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.swing;
			effect(1).setValue(10);
			effect(2).setValue(1);
			
			prop.expression = "//Duik.swing\r\n" + 
								"amp = effect('" + effect.name + "')(1);\n" +
								"freq = effect('" + effect.name + "')(2)*2*Math.PI;\n" +
								"decalage = framesToTime(effect('" + effect.name + "')(3));\n" +
								"amorti = Math.abs(effect('" + effect.name + "')(4));\n\n" +
								"sin = Math.sin(time*freq+decalage);\n\n" +
								"for(i=0;i<amorti;i++) {\n" +
								"sin = Math.sin(sin);\n" +
								"}\n" +
								"sin*amp+value;";
			
			return true;
		}
	}
	/* WHEEL - Duik.wheel(layer,radius,curved);
	
		Automates the rotation of the given layer using its position.
		If curved, works even if the trajectory is not horizontal, but is heavier to compute.
	
		parameters
		layer | AVLayer
		radius | float, default 100.0
		curved | boolean, default false
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.wheel !== 'function' || Duik.forceReload)
	{
		Duik.wheel = function (layer,radius,curved)
		{
			if (radius == undefined) radius = 100;
			else if (! (radius > 0)) radius = 100;
			if (curved == undefined) curved = false;
			var effect = Duik.utils.rigProperty(layer,layer.transform.rotation,"Duik_wheel.ffx");
			if (effect == null) return false;
			effect.name = Duik.uiStrings.wheel;
			effect(1).setValue(radius);
			
			if (!curved) layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 
																"O = thisLayer.toWorld(thisLayer.anchorPoint);\n" + 
																"R = thisLayer.effect('" + effect.name + "')(1);\n" + 
																"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 
																"result = 0;\n" +
																"R > 0 ? result = radiansToDegrees(O[0]/R) : result = 0 ;" +
																"Rev == 1 ? value - result : value + result;";
			else layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 
															"R = thisLayer.effect('" + effect.name + "')(1);\n" + 
															"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 
															"var precision = 1;\n" + 
															"function pos(frame)\n" + 
															"{\n" + 
															"return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n" + 
															"}\n" + 
															"function roue()\n" + 
															"{\n" + 
															"if (R<=0) return value;\n" + 
															"var distance = 0;\n" + 
															"var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n" + 
															"var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n" + 
															"for(i=start;i<end;i+=precision)\n" + 
															"{\n" + 
															"if (pos(i+precision)[0] - pos(i)[0] > 0) distance += length(pos(i+precision),pos(i));\n" + 
															"else distance -= length(pos(i+precision),pos(i));\n" + 
															"}\n" + 
															"return radiansToDegrees(distance/R) ;\n" + 
															"}\n" + 
															"Rev == 1 ? value - roue() : value + roue();";
			
			return true;
		}
	}
	/* MORPHER - Duik.morpher(layers);
	
		Adds a "morpher", a slider to easily control interpolations of selected properties of the given layers.
	
		parameters
		layers | Array of AVLayer
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.morpher !== 'function' || Duik.forceReload)
	{
		Duik.morpher = function (layers)
		{
			//récupérer la sélection d'effets du premier calque, puisqu'elle sera perdue à la création de la glissière..... (voir avec adobe si vous trouvez ca pas pratique)
			var selection = [];
			effets =  layers[0].selectedProperties;
			for (j=0;j<effets.length;j++) {
			if (effets[j].canSetExpression && effets[j].parentProperty.isEffect) {
				 var layerIndex = app.project.activeItem.selectedLayers[0].index;
				 var effetIndex =  effets[j].propertyIndex;
				 var effetParentName = effets[j].parentProperty.name;
				selection.push([layerIndex,effetParentName,effetIndex]);
				delete effetIndex;
				delete effetParentName;
				}
			}

			//créer le curseur
			var morpher = layers[0].Effects.addProperty("ADBE Slider Control");
			morpher.name = "Morpher";

			//boucle pour appliquer le morpher sur la sélection perdue
			for (i=0;i<selection.length;i++)
			{
				var effet = layers[0].effect(selection[i][1])(selection[i][2]);
				effet.expression = "//Duik.Morpher\r\nvalueAtTime((thisComp.layer(\"" +  layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
				//la boucle pour créer automatiquement des clefs sur le morpher :
				if (Duik.settings.morpherCreatesKeyframes)
				{
					//nombre de clefs
					var nbreClefs = effet.numKeys;
					//durée d'image de la compo
					var ips = app.project.activeItem.frameDuration;
					var temps = 0;
					var prop = effet;
					for (k=1;k<=nbreClefs;k++)
					{                 
						//récupère l'instant de la clef
						temps = prop.keyTime(k);
						//crée une image clef sur le morpher
						morpher(1).setValueAtTime(temps,temps/ips);
					}
					delete temps;
					delete prop;
					delete ips;
					delete nbreClefs;   
				}
			}

			//boucle pour appliquer le morpher partout
			for (i=0;i<layers.length;i++)
			{
				for (j=0;j<layers[i].selectedProperties.length;j++)
				{
					var effet = layers[i].selectedProperties[j];
					if (effet.canSetExpression && effet.parentProperty.name != "Morpher")
					{
						effet.expression = "valueAtTime((thisComp.layer(\"" + layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
						//la boucle pour créer automatiquement des clefs sur le morpher :
						if (Duik.settings.morpherCreatesKeyframes)
						{
							//nombre de clefs
							var nbreClefs = effet.numKeys;
							//durée d'image de la compo
							var ips = app.project.activeItem.frameDuration;
							var temps = 0;
							var prop = effet;
							for (k=1;k<=nbreClefs;k++)
							{                 
								//récupère l'instant de la clef
								temps = prop.keyTime(k);
								//crée une image clef sur le morpher
								morpher(1).setValueAtTime(temps,temps/ips);
							}
							delete temps;
							delete prop;
							delete ips;
							delete nbreClefs;   
						}
					}
				}
			}

			return true;
		}
	}
	/* LENS FLARE - Duik.lensFlare(layers);
	
		Rigs the layers to move like a lens flare.
	
		parameters
		layers | Array of AVLayer
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.lensFlare !== 'function' || Duik.forceReload)
	{
		Duik.lensFlare = function (layers)
		{
			//sortir le premier calque, le centre, et ajouter les contrôleurs
			var centre = layers.shift();
			var nomcentre = centre.name;
			var centerEffect = Duik.utils.addPseudoEffect(centre,"Duik_lensflare.ffx");
			centerEffect.name = Duik.uiStrings.lensFlare;
			centerEffect(1).setValue(100);
			centerEffect(2).setValue(100);

			//l'expression de position
			var positionexpression = "//Duik.LensFlare\r\n" + 
			"calqueCentre = thisComp.layer(\"" + nomcentre + "\");\n\n" +
			"function positionAbs(calque) {\n" +
			"return calque.toWorld(calque.anchorPoint)\n" +
			"}\n\n" +
			"n=effect(\"" + centerEffect.name + "\")(1);\n\n" +
			"X = thisComp.width - positionAbs(calqueCentre)[0];\n" +
			"Y = thisComp.height - positionAbs(calqueCentre)[1];\n\n" +
			"if ( n<100 ) {\n\n" +
			"i=n/100;\n" +
			"j=1-i;\n\n" +
			"value + ( (  [X,Y]*(i/j) + positionAbs(calqueCentre) )*j\n\n )" +
			"}\n\n" +
			"else {value + [X,Y] }";

			//l'expression d'opacité
			var opaciteexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + centre.name  + "\").effect(\"" + centerEffect.name + "\")(1);\n" + "value*n/100";
			
			//l'expression d'échelle
			var tailleexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + nomcentre  + "\").effect(\"" + centerEffect.name + "\")(2);\n" + "value*n/100";
			
			//appliquer les expressions sur le centre
			centre.transform.opacity.expression = opaciteexpression;
			centre.transform.scale.expression = tailleexpression;

			//la boucle d'application des expressions et contrôleurs
			var nombrecalques = layers.length;
			for (layerI = 0; layerI < nombrecalques; layerI++)
			{
				calque = layers[layerI];
				calque.position.setValue([0,0]);
				//le controleur de la distance
				var distanceEffect = Duik.utils.addPseudoEffect(calque,"Duik_lensflaredistance.ffx");
				distanceEffect.name = Duik.uiStrings.lensFlare;
				distanceEffect(1).setValue(100/nombrecalques*(layerI+1));
				
				//appliquer les expressions
				calque.transform.position.expression = positionexpression;
				calque.transform.opacity.expression = opaciteexpression;
				calque.transform.scale.expression = tailleexpression;
				
				//fin de la boucle
			}
			
			//sélectionner le centre (controleur)
			Duik.utils.deselectLayers();
			centre.selected = true;
		}
	}
		/* DISTANCE LINK - Duik.distanceLink(layer,property,parentLayer);
	
		Link the property to the distance of parentLayer
	
		parameters
		layer | AVLayer containing the property
		property | Property to rig
		parentLayer | AVLayer which distance from layer is used to rig
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.distanceLink !== 'function' || Duik.forceReload)
	{
		Duik.distanceLink = function (layer,prop,parentLayer)
		{
			//add effect
			var effect = Duik.utils.rigProperty(layer,prop,"Duik_distancelink.ffx");
			if (effect == null) return false;
			effect.name = Duik.uiStrings.distanceLink;
			//get the distance between the two layers
			var distance = Duik.utils.getDistance(layer,parentLayer);
			effect(2).setValue(distance - distance/4.0);
			effect(3).setValue(distance + distance/4.0);
			
			if (parentLayer instanceof CameraLayer)
			{
				prop.expression = "//Duik.DistanceLink\r\n" + 
					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 
					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 
					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 
					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 
					"falloff=effect(\"" + effect.name + "\")(6);\n" + 
					"function positionAbs(calque) {\n" + 
					"return calque.toWorld(calque.anchorPoint);\n" + 
					"}\n\n" + 
					"distance = length(calqueRef.position,positionAbs(thisLayer));\n" + 
					"if (distMax>=distMin && falloff!=0){\n" + 
					"if (distance <= distMax && distance >=distMin) {value}\n" + 
					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 
					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 
					"if (distMax==0){value + distance/falloff}\n" + 
					"}else {value}";
			}
			else
			{
				prop.expression = "//Duik.DistanceLink\r\n" + 
					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 
					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 
					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 
					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 
					"falloff=effect(\"" + effect.name + "\")(6);\n" + 
					"function positionAbs(calque) {\n" + 
					"return calque.toWorld(calque.anchorPoint);\n" + 
					"}\n\n" + 
					"distance = length(positionAbs(calqueRef),positionAbs(thisLayer));\n" + 
					"if (distMax>=distMin && falloff!=0){\n" + 
					"if (distance <= distMax && distance >=distMin) {value}\n" + 
					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 
					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 
					"if (distMax==0){value + distance/falloff}\n" + 
					"}else {value}";
			}
			
		}
	}
}());



